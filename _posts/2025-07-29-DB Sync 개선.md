---
title: "DB Sync 개선"
date: 2025-07-29
tags:
  - DB
  - 개발
category:
  - 기술
---

현재 정보보호 요건을 만족시키기 위해 서비스로 들어오는 모든 요청들을 서비스와 같은 RDB에 저장하고 있다.
api-gateway에서 들어온 MCI 서비스코드, input, 나갈때 output, 고객식별자 이런 값들을 저장중임.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/c38aebd7-2834-4fac-b2fc-a2f0c17ce81d/332bcab7-bc0a-42c5-9b35-c6d0dc6c9cf3/image.png)

이런 느낌 ㅜㅜ(빨간줄)

문제는 다음과 같다.
1. EDB에 커넥션이 너무 많이 들어간다.
2. EDB를 사용하지 않더라도 무조건 거쳐야 한다.
3. request > db에 요청이력 insert > 서비스 갔다가 > db에 응답이력 insert > response 이므로 느리다.

최종적인 결론은 진작에 나긴 했었다. 카프카가 들어오면 거래이력을 kafka에 pub 하고 정보계에서 별도로 후처리 sub 하는 식으로 관리하기로.
근데 이게 언제 구성될지도 모르고 카프카도 이거 만든 당시에는 아예 없었기 때문에 우선 카드계 공통 테이블에서 로깅하는 방식 그대로 차용해서 정보보호 요건 대응했다.

### 문제 - 수문장 DB

전술했듯이, 일단 요청이 들어오면 api-gateway 에서 db insert로 한번 막히고 갔다가 나오면서 db insert로 한번 총 두 번 막힌다. 
이 문제는 카프카가 들어오기 전에 크게 세 가지 간단한(?) 방법으로 해결 가능해 보인다. 조합해서 써도 될듯.
  1. r2dbc 사용
    - 논블로킹으로 처리, 수신개발팀쪽에서는 이걸 썼던것 같더라.
    - jpa 연관관계 영속성 이런건 필요없다. 단순 후처리성 논블로킹 insert만 하면 되므로 부가기능 없이 속도만 겁나빠른 것도 괜찮음.
  2. Async 적재 
    - 스레드풀 관리 필요할 수 있음. 아마 크게 문제는 없을듯?
    - r2dbc 레퍼런스도 많이 없고 간단하게 처리만 하려면 현재 상황에서는 단순히 async만 사용해도 괜찮을 것 같음.
  3. jparepository에서 save 할 때 select 안하도록
    - Persistable 엔티티 사용
1,3 또는 2,3 을 조합해서 해결하면 될듯함.
다만 결국에는 스레드풀을 동시는 아니지만 두 번 사용한다는 점에서 여전히 불만족 + 굳이 로그 정보를 rdb에 유지하고 싶지도 않아.