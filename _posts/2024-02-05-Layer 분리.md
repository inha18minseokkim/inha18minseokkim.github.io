---
title: "Layer 분리"
date: 2024-02-05
tags: [미지정]
category:
  - 기타
---
원래는 그냥 Service에서 Entity를 Out 하는것을 허용하기로 했음
  - 굳이 Repository에서 다시 find를 해야하나 싶기도 했고
  - Serialize 허용 하지 않게 하면 N To M 양방향관계 Recursive 문제도 사라짐
다만 캐싱하려고 하니깐 자꾸 문제가 발생해서 그냥 Service Layer까지는 Entity를 DTO로 매핑하기로 함(Code Convention으로 강제함)

다만 Persistence Layer의 경우엔…고려를 좀 해봐야할듯

+추가) Persistence Layer도 DTO로 변환하는것으로 
  - 왜냐하면 Mybatis도 사용해야함. 그러므로 Repository는 JpaRepository를 사용하되(Mybatis를 구현한 Repository를 구현해도 되지만 굳이?) Reader Layer를 두고 거기다가 QueryDSL,Mybatis,Jdbc를 사용 ㄱㄱ

분리 전

```java
@Builder
@Data
@ToString
public class GetPriceDiffListIn {
    private UserGroupCode regionGroup;
    private String startDate;
    private String endDate;
}
```


분리 후

```java
@Builder
@Data
@ToString
public class GetPriceDiffListInDto {
    private String regionGroupCodeId;
    private String startDate;
    private String endDate;
}
```


Mapper로 export 할 때 id값 내보냄

```java
public interface InnerProductRepositoryMapper {

    @Mappings({
            @Mapping(target="innerCategoryId",expression = "java(element.getInnerCategory().getId())"),
            @Mapping(target="baseProductIds",expression = "java(element.getBaseProducts().stream().map(e->e.getId()).toList())")
    })
    FindInnerProductWithFilterOutDto from(InnerProduct element);
}
```


이렇게 하는 이유는 JDBC,MyBatis,JPA,QueryDSL 모두 사용하기 위함
크게 세 가지 이유
1. Serialize 문제(Redis,Lombok)
2. JPA Mybatis 호환 문제(인터페이스) & 통일성 문제
3. 단위 테스트 문제


## Serialize 문제


```java
@ManyToOne(cascade = CascadeType.ALL)
@JoinColumn(name="innerCategoryId",referencedColumnName = "id",foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT))
private InnerCategory innerCategory;
```


```java
@OneToMany(mappedBy = "innerCategory",cascade = CascadeType.ALL)
@ToString.Exclude
@JsonIgnore
private List<InnerProduct> subProducts;
```

이런식으로 양방향 참조관계로 설정되는 경우 ToString 호출 시 서로 재귀호출하면서 무한루프 빠짐.
  - 물론 ToString.Exclude를 설정할 수 있음. 이러면 Lombok Serializer는 해결, Redis는 또 따로 설정해야함(귀찮)
그리고 Entity를 Serialize하면 Lazy로 설정 해놓는다고 해도 불필요한 정보들이 캐시에 올라감. 그럴바에는 그냥 id속성만 올리자


## 호환문제 & 통일성 문제

일단 Entity Class를 입출력으로 허용하게 된다면 구현부 내의 코드는 깔끔해짐. 왜냐하면 Repository Find 안하고 바로 받아서 쓰면 되므로
하지만 Mybatis나 JDBC를 사용한다면 쿼리로 데이터를 뽑긴 했는데 얘를 영속성 컨텍스트에 또 올려야 함. 안그러면 JPA가 해당 엔티티(영속성 컨텍스트에 올라가있지는 않는데 데이터는 target Row 와 똑같음)
반대로 JPA를 사용할 함수구현부에서 Mybatis로 구현한 서비스를 호출한 경우 영속적이지 못한 엔티티를 받게 될 수 있으므로
그럴바엔 그냥 dto 출력으로 바꾸자


### 단위 테스트 문제

개인적으로 단위테스트 할 때 entity 불러오는 로직 짜는것 번거롭고 신경쓰고 싶지 않음

이런식으로 id 값으로 해도 가독성은 괜찮은듯?
(대충 어떤 고객이 어떤 내부상품을 어떤 지역으로 조회했다는 이력을 추가하는 서비스)

```java
//멤버 조회 이력 insert
memberService.insertProductHistory(InsertProductHistoryCriteria.builder()
                                .innerProductId(criteria.getInnerProductId())
                                .regionGroupCodeId(criteria.getRegionGroupId())
                                .memberInfoId(member.getMemberInfo().getId())
                                .build());
```

뒷단에서 이런식으로 JPA 구현

```java
@Transactional
public void insertProductHistory(InsertProductHistoryCriteria in) {

    customerSearchHistoryRepository.save(CustomerSearchHistory
            .builder()
            .innerProduct(innerProductRepository.findById(in.getInnerProductId()).orElseThrow())
            .memberInfo(memberInfoRepository.findById(in.getMemberInfoId()).orElseThrow())
            .regionGroup(userGroupCodeRepository.findById(in.getRegionGroupCodeId()).orElseThrow())
            .submitTime(LocalDateTime.now())
            .build());
}
```

아니면 Mybatis를 사용해서 직접 insert를 구현해도 된다.