---
title: BM들에게 보내는 편지 - EDA
date: 2025-10-31
tags:
  - EDA
  - 세션
  - 케이뱅크
  - 개발
category:
  - 실무경험
  - 발표자료
---

### 현재 편의서비스에 배포되고 있는 서비스들의 구조 - MSA

하나의 애플리케이션을 ‘독립적으로 배포 가능한 서비스 단위’로 분할을 하여, 서로 간의 변경과 조합이 가능하도록 이루는 구조를 갖는 것을 의미합니다.
![이미지](/assets/images/Pasted%20image%2020260225094247.png)

주식 서비스의 경우 크게 MSA가 필요한 아키텍쳐는 아니지만 이런식으로 N 가지의 업무에 최대 M가지의 독립된 컨테이너가 상호작용하면서 서비스되고 있습니다.
다양한 서비스들이 서로 상호작용을 하기 때문에 영향도 문제가 커지고 있는데(물론 이건 기존 시스템에서도 비슷한 문제긴 함)
  1. 한곳의 장애가 전파될 수 있다.
    1. a>b>c로 가는 와중에 b에서 장애가 생기면 a는 계속 오류를 리턴하고, 최악의 경우 만약 거래가 밀린다면 a도 죽을 것임.
  2. 각 업무의 dependency로 인해 특정 업무가 복잡해질 수 있다.
    1. 1을 하고 2를 하고, 2를 한 뒤에 무조건 3과 4를 하고 3과 4가 끝난 뒤에 5를 하고,, 비동기로 6을 하는데 3의 결과를 가지고 하고..
    2. 계정계나 카드쪽 이야기를 들어보거나 코드를 보면 이런식의 업무가 상당히 많고 보통 이런 코드를 보면 주석과 문서로 설명이 열심히 되어있는 것을 볼 수 있다.

### EDA란? (Event Driven Architecture)

- **분리된 서비스 혹은 시스템들 간의 이벤트를 게시, 소비 또는 라우팅 동작을 통해 각 정보를 공유하는 형태로 구성된 아키텍처를 의미합니다.**
- 다시 말해, 분리된 서비스들 간의 ‘상태 변화’가 발생한 경우에, 이벤트 생성자는 비동기식으로 이벤트를 게시(Publish)하며, 소비자는 사전에 특정 이벤트 수신을 구독(Subscribe)하여 이벤트가 게시되면 해당 이벤트를 수신하여 동작 처리를 수행합니다. 라우팅은 이 생성자와 소비사 사이에 이벤트 통신을 중재합니다.
- 이를 통해, 이벤트를 게시하는 이벤트 생성자와, 이벤트를 처리하는 이벤트 소비자는 독립적으로 동작할 수 있습니다. 그렇기에 서로 간의 ‘느슨한 결합’으로 구성되어 확장성과 유연성이 향상됩니다.
- 이벤트 기반 아키텍처는 주로 실시간 응용 프로그램, 분산 네트워크, 마이크로서비스, 서버리스 아키텍처 등 환경에 적합합니다.

어디 블로그에서 긁어왔는데, 한줄요약 하자면 위와 같이 dependency가 있는 것이 아니라 특정 이벤트에 대해 listening을 하고 있다가 이벤트가 들어오면 해당 티켓만 처리하는 형식임
그러다보니 다음과 같은 장점이 있음
1. 한 곳으로 장애가 전파될 확률이 낮음.
  1. 가령 a의 이벤트 a’ / b의 이벤트 b’ / c의 이벤트 c’가 있고,
    - b는 a’를 보고 b’ 아웃풋을 내고
    - c는 b’를 보고 c’ 의 아웃풋을 낸다고 가정해보자
    - 만약 업무 c가 실패해버린다고 해도 b에 영향을 미치지 않는다. b는 계속해서 a’를 활용해서 b’를 도출하기 때문이다.
2. 특정 업무가 복잡해지지 않는다.
  - 각 업무는 dependency를 신경쓰지 않고 본인이 위임받은 로직만 처리하기 때문에 복잡한 업무를 단순하게 풀어낼 수 있다
  - Q) 근데 어차피 A B C를 다 신경써야하면 업무가 복잡한건 매한가지 아닌가요?
  - A) divide and conquer와 비슷한 감성 이라고 보면 될것 같다. 특정 업무를 볼 때 한 가지에만 집중을 한 다음 aggregate를 하면 좀 더 단순하지 않을까? 커뮤니케이션 입장에서도 

### 예시) 출석 후 아이템을 받는 씬

아이템을 랜덤생성하고 아이템을 인벤토리에 넣는 행위가 많은 burden을 유발한다고 가정하면 좀 더 도움이 된다
![이미지](/assets/images/Pasted%20image%2020260225094634.png)

보통 플로우를 설계하면 다음과 같이 설계한다
output을 보면 출석카운트가 2인 경우 아이템 정보는 Null 이고 3이상인 경우는 아이템이 있을 것이다. 현재 채널에 이러한 데이터를 리턴해주면 아이템 번호가 있는 경우 고객에게 출석 후 아이템 뽑은 씬을 보여줄 것이다.

다음과 같은 문제가 생길 수 있다.
  1. 아이템 뽑는부분에서 장애가 생기면 출석을 못한다
  2. 출석과 아이템이 커플링 되어버려서 아이템 로직을 고칠 때 출석 로직을 같이 고려해야 한다.
    1. 물론 내부에서 구현을 어떻게 해놨냐에 따라 극적으로 달라지겠지만.. 두 비즈니스의 조합이 일어난다
  3. 그래서 복잡해질 수 있다.

다음과 같이 설계해보면 어떨까?
![이미지](/assets/images/Pasted%20image%2020260225094640.png)

큐가 추가된 것을 볼 수 있다.
큐만 추가되었는데 무엇이 달라진것인가? 논리적으로 기존에는 크게 두 파트였는데 세 파트로 나눠진 것이다.
![이미지](/assets/images/Pasted%20image%2020260225094645.png)

기존에는 클라이언트 부분과 출석&아이템 지급 부분이 있었지만 출석과 아이템 지급 부분이 나눠졌다.
아이템 지급 부분이 가정했듯이 상당히 부담스러운 로직이어서 지연되는 경우 고객에게 출석 결과를 리턴하는데 상당한 시간이 소요될 수도 있지만, 큐로 중간에 한 번 끊어주면(큐에 발생하는 IO <<<< 넘사벽 <<<< 아이템을 랜덤 생성하고 인벤토리에 저장하는 로직) 안정적으로 고객에게 출석 성공여부를 알릴 수 있다.

\> 1번 문제 해결!

출석은 출석 로직만 수행하면 되고, 아이템 지급 부분은 아이템 지급 부분만 해결하면 된다.

\> 2,3번 문제 해결!

하지만 이러한 방법은 현재 개발환경에서** 사용할 수 없는 **~~**사소한**~~** 문제**가 있다.


### 아이템 지급 결과에 대한 지속적인 트래킹 불가

출석 후  카운트가 3이면 아이템을 조회해야하는데, 아이템 지급이 늦어지는 경우 고객이 **아이템 지급 여부에 대해서 알 방법이 없다**보니 채널에서 계속 조회를 시도해야한다.
  - Best Practice가 뭔가요? 라고 물어본다면 아래와 같다.
![이미지](/assets/images/Pasted%20image%2020260225094701.png)

(빨간선 참고) 프론트 스택에서 Flux나 grpc를 지원한다면 최대한 가볍게 조회를 해올 수 있지만 우리는 무거운 MCI 호출(은행 거래, HTTP POST, 거래 내역을 구간별로 db에 기록하고 변환하고) 을 해야 함. 심지어 Http 타임아웃 기본값이 70초 이므로 이런식으로 가볍고 빈번하게 일어나야 하는 조회를 수행하기에는 적절하지 않은 구조. 
  - 현재 채널에서 최대한 비슷하게 구현하려고 한다면 (예를들어) 고객이 메인화면에 있는 동안 비동기로 3초에 한 번씩 계속 MCI를 호출하는식으로 만들어야 하는데, MCI 담당자분께서 화들짝 놀라서 달려오실 것 같다. 단순 조회 때문에 thread starvation이 나서 다른 계정거래가 밀릴 수도 있기 때문.
그러므로 스트림이나 롱 폴링 방식은 우리 행에서 사용할 수 없다.(계정계 백엔드를 호출할 때 MCI를 **반드시 거쳐야 한다**는 표준을 준수하는 한)

Aws Summit Seoul 2025에서 삼성카드 EDA 세션을 들었을 때 강연자분께서 하신 말씀이 생각나서 가져와봤다.
>  EDA를 도입하기 전에 우리가 반드시 신중하게 따져봐야 할 몇 가지 핵심 사항들이 있습니다. 먼저, **해당 비즈니스 도메인이 이벤트 기반 아키텍처에 적합한지**, 그리고 **요구사항들을 비동기적으로 처리할 수 있는지** 면밀히 검토해야 합니다. 더불어 **데이터의 정합성과 멱등성을 확보하기 위한 방안**, 그리고 **프론트엔드에서의 비동기 처리 지원 여부 **또한 중요한 고려 사항입니다.
이러한 내용으로 미루어보았을 때, 완벽한 이벤트 드리븐의 길은 멀고도 험하다.
[ITing - [AWS SUMMIT 2025] 나에게 맞춤 혜택을큐레이션:삼성카드의AI기반 실시간 추천 시스템현대화 사례](https://iting.co.kr/aws-summit-seoul-2025-techblog-10/)

### 대안- 이대로 있을 수 만은 없지,,

위와같은 ~~중대한~~ 문제점이 있기 때문에 완벽하게 이벤트 드리븐으로 구현하기에는 한계가 있다. 그렇다고 손 놓고 바라보고만 있을 수는 없다. 최대한 될 때 까지는 해봐야 하지않을까?

# 기획&디자인 시 고려해야 할 점 - 기획자에게 바란다!!

위 인용문을 봤을 때 이벤트 드리븐을 도입하기 위해서는 다음과 같은 사항을 고려해야 한다.
1. 비즈니스 도메인이 이벤트 기반 아키텍처에 적합해야 한다.
2. 요구사항을 비동기적으로 처리할 수 있어야 한다.
3. 데이터의 정합성과 멱등성을 확보해야 한다.
4. 프론트엔드에서 가벼운 비동기 처리를 지원해야 한다.
4번의 경우는 현 시점에 실현이 불가능하다는 사실을 인정하고, 3번의 경우는 백엔드 개발자의 롤이므로 상수로 두고 생각해보자.

1,2번을 확보하면 100% 완벽하지는 않지만 상당부분 이벤트 드리븐으로 구현 가능할 것이라는 생각이 든다.
1, 2번의 경우 거의 온전히 비즈니스 요건의 제약 사항이라고 생각하기 때문에 기획단에서 어느 정도 이벤트 기반의 처리를 생각해서 열린 마음으로 기획서를 작성해준다면 좋겠다는 생각.
  - 실제로 계정 프레임워크를  MSA 로 전환하는 관련 논의들을 살펴보면 새로 만들면서 사업 요건부터 다시 잡는 그런것들이 많다.
그래서 처음에 설계가 중요하다고 생각한다.
  - 이벤트 드리븐으로 특정 이벤트를 처리하는 식으로 서비스를 설계하면 플로우를 그리는 것은 처음에는 다소 어려울 수 있겠지만 1. 처리량에 있어서 이득을 볼 수 있고 2. 단위 로직에 대한 핸들링이 용이해진다는 장점이 있다.

### 기획안 수정 요청) 선물함(게임화면은 본인과 관계가 없음)

위(이벤트 드리븐을 사용할 수 없었던) 예시를 극복하려면 어떤식으로 기획 방향을 바꾸면 될까? 
가장 간단하게 생각해볼 수 있는 방법은 선물함이다.(아래 게임과 본인은 관계가 없다)

![이미지](/assets/images/Pasted%20image%2020260225094724.png)

꼭 출석을 하자마자 아이템을 뽑고 사용하는것이 아니라, 출석을 해서 아이템이 지급되었으니 아이템함에서 확인해보세요 라는 말을 하게 된다면 굳이 트랜잭션을 보장하거나 무조건적인 폴링을 시도할 필요가 없고, 부하가 큰 로직을 **고객의 행위에 의해서 일어나도록 **유도하면 될 듯 하다.

![이미지](/assets/images/Pasted%20image%2020260225094731.png)

늘 그렇듯 실제로** 다음 행동을 하는 고객은 극소수**일 확률이 높기 때문이다.
  - 그러므로 출석 후 바로 아이템 지급 결과를 고객에게 보여주는것은 높은 처리량을 가져가기 위해 타협할 수 있는 요건이지 않을까? 라는 생각이다.

완벽하게 프론트단에서 이벤트 드리븐으로 처리하면 좋겠지만 그렇지 않는 경우 약간의 변형만으로도 어느정도 목표를 달성할 수 있다. 
물론 “출석한 후 아이템이 지급될거에요 라고 해놓고 바로 안들어와서 고객이 아이템함을 열었을 때 비어있는것을 극도로 꺼려한다” 면 위 논리는 더이상 통하지 않는다.
 하지만  **“아이템 지급이 늦어져서 출석 자체가 실패해서 출석버튼을  다시 누르세요”** 와  **“어차피 아이템 지급이 실패할건데 출석이라도 성공해서 고객에게 출석을 다시 시도하라고 안내하는 상황을 피하는 것”** 중 어느것이 더 나을까.. 
다양한 비즈니스 요건에 따라 다양한 정답이 있겠지만 지금 편의서비스를 개발하고 있는 내 입장에서는 “일단 출석은 되게 하자” 가 더 좋아보인다
물론 이번 기획에서는 출석 > 출석 3일차 이상부터는 아이템 뽑기 > 주식 둘러보기의 flow를 굉장히 중요시 하시는 것 같아 해당 기획안 수정안은 접어두었다,, 담당자가 생각하시는 가치가 그렇다면 그럴 수 있는 것이다. 논의를 할 수 있었던 것만 해도 감사하다,,

그래서 이번에 이벤트 드리븐으로 만든 네 개 중 하나는 현재 프론트에서 결과 조회를 할 수 있을 만한 스택이 아니라는 한계 때문에 드랍되었고, 실제로 운영에 적용된 사례를 살펴보도록 하자.
크게 세 가지 업무를 적용하였는데, 다음과 같은 이점을 가져갔다.
- 리워드 현금지급 > 디커플링을 통한 I/O 부담 감소
- 푸시 발송 > 디커플링을 통한 I/O 부담 감소
- 초대 아이템 지급 > 샤딩을 통한 경합/경쟁 상태 방지

위와 같은 이점을 가져갔는데 기존에 존재하던 프로세스에서 어떻게 영감을 얻었는지, 굳이 왜 중간에 큐를 두었는지 순으로 기술해보겠다.


### 비슷한 사례 학습 - 돈나무 <> 계정계 현금 리워드 지급 프로세스

이벤트 드리븐이라는게 특별히 대단한 것은 아니라고 생각하고 기존 프로세스에서도 어느 정도 녹아들어 있는것을 볼 수 있다.
![이미지](/assets/images/Pasted%20image%2020260225094739.png)

돈나무 같은 경우에는 카드 BXM <> EAI <> 계정계 BXM 싱크 구조를 사용한다. 
싱크 구조라면 위에서 말한 문제점들이 일어나는것이 아닌가요? 라는 의문이 들 수 있지만, 연동 구조를 자세히 들여다 보면 아래와 같다
1. 고객이 물주기 시도
2. 물주기 시도 후 리워드 지급내역 테이블에 내역 insert(status READY)
3. 카드BXM > EAI 호출
4. 계정계 응답 수신 후 테이블 update(status OK)
5. 고객에게는 리워드가 지급 될 “거에요” 로 메세지를 나가고 1~2초뒤 푸시로 현금 지급을 인지(물론 트래픽이 많으면 좀 더 걸림)
6. 만약 계정계나 EAI에서 응답을 받지 못한다면 1~5분주기로 수행되는 재처리 배치가 수행되어 READY 상태의 내역을 다시 요청한다
![이미지](/assets/images/Pasted%20image%2020260225094745.png)

무거운 작업(리워드 지급)이 리워드 지급과 확인의 시점이 분리될 수 있다.
해당 프로세스와 주간 투자왕 리워드 프로세스는 거의 비슷하기 때문에 해당 프로세스에서 약간의 변형을 넣어봤다.
![이미지](/assets/images/Pasted%20image%2020260225094756.png)

위와 아래의 차이점은 1. 테이블 대신 큐를 사용하는 것 2. 리워드 처리 결과를 확인조차 하지않고 무조건 대기열에 넣는것 이라고 볼 수 있다.

이렇게 해도 되냐는 질문을 많이 받아서 역으로 질문을 바꿔보겠다..

## 역질문) 현금 지급에 대한 결과를 바로 고객에게 보여줘야 하는가?

입출금 개발 담당자는 YES(이체 및 입출금 실패하면 고객에게 알려주고 재시도 해야함) 라고 할 것이고 게임 개발자는 NO라고 할 것 같다.
서로 담당하는 비즈니스의 관심사와 주된 화면이 다르기 때문에 이런 다른 답변이 있을 것이라고 생각한다.

### 굳이?? 꼭? 바로? 보여줘야? 하나요??

![이미지](/assets/images/Pasted%20image%2020260225094806.png)

고객은 게임 화면에서 리워드 지급여부를 확인할 수 없다. 
  - 리워드가 지급될 거에요!! 확인해보세요!(여기서 말고 뒤로 가서) 라고 커뮤니케이션 할 수 있기 때문에 무거운 처리를 뒤로 숨길 수 있다.


### 요점 : 기술의 문제보다는 비즈니스를 어떻게 정의하고 협의할 것이냐의 문제

꼭 카프카나 메세지큐를 사용해야만 EDA를 완성할 수 있는것은 아니다. 중요한 것은 기술적인 문제가 아니라 어떤 것을 핵심 가치로 가져갈 것이냐에 따라 다를 것 같음
그리고 처리량을 늘리기 위해서 기획자와의 협상과 프로세스의 핵심과 그렇지 않은 것들을 과감하게 분리할 필요가 있지 않을까.

# 번외) 왜 MSA 환경에서 큐 기반 이벤트 드리븐을 집착하시나요??


### 케이뱅크 MSA 환경에서는 처리성 업무 EDA가 효과적

되게 많은 설명이 있을 것 같은데, 짧은 경험으로 비추어 보았을 때 한 문장으로 대답을 하자면
  - 작게 나눠져있는 MSA 환경에서 작업을 효율적으로 분배하기 위하여
라고 할 수 있겠다. 적어도 지금 운영환경에서는 딱 이정도 목적인 것 같다.

![이미지](/assets/images/Pasted%20image%2020260225094838.png)

mciap는 프론트에서 오는 호출이라고 생각하고, 중앙에 있는 작고 귀여운 파드가 내가 운영하는 서비스라고 생각하고, 리워드 지급을 위해서는 corap를 호출한다고 생각하면 된다. 실제로 mciap 인스턴스는 4대, corap는 6대가, MSA 환경은 기본적으로 파드 4대정도로 스케줄링을 하는데  있다고 생각하면 엄청난 자원 차이다.

![이미지](/assets/images/Pasted%20image%2020260225094848.png)

하지만 위 두 근육시바의 처리량의 상한선은 고정되어있지만(처리량을 늘리기 위해서는 CAPEX 예산 및 L4 추가 계획부터 잡아야 함) MSA 환경의 인스턴스는 (멱등처리 및 자원의 확대가 가능하다는 하에) 늘리는 만큼 늘릴 수 있다는 장점이 있다.
지금 이 상황에서 모놀리틱과 마이크로서비스의 차이가 나온다.
모노환경은 특정 작업 및 호출에 접근하는 인스턴스의 개수가 정해져있거나 많이 변하지 않는다.
  - 계정계의 경우 1호기 호출, 2호기 작업 등 뭔가 수평적인 스케일링이 방법은 있겠지만(샤딩 등) 쉽지않다.

![이미지](/assets/images/Pasted%20image%2020260225094906.png)

대신 하나의 인스턴스가 상당히 막강하기 때문에 그냥 돌린다. 행 내 UMS, 돈나무 리워드, 센터컷 등의 비동기 상주 배치 작업들은 위와 같은 스킴으로 진행된다.

마이크로서비스 환경은 수평적으로 확장이 가능하다는 전제하에 개발된다.

![이미지](/assets/images/Pasted%20image%2020260225094937.png)
!(https://m.gameshot.net/common/con_view.php?code=GA65bcc0af14cd9)

  - 팰월드를 해본 사람이면 알겠지만 건물을 건축하면 대기하고 있던 N마리의 팰들이 달려와서 뚝딱뚝딱 망치질을 한다. 팰이 해당 작업에 많이 붙으면 많이 붙은 만큼 시간은 비례해서 감소한다. 
    - 위 사진은 쉬고 있는 펠(좌상단 5초 남음) 들이 십시일반 플레이어를 도와서 건축을 빠르게 완료하는 모습.

게임으로 이해했다면 이제 실제 이미지를 보도록 하자.

![이미지](/assets/images/Pasted%20image%2020260225095010.png)

이런 식으로 특정 작업을 잘게 쪼개어서 카프카 큐에 넣어놓으면 N개의 파드가 작업을 수행하는 방식을 현재 케이뱅크 주간 투자왕 리워드 지급 부분에서 사용하고 있다. 아무래도 리워드 지급이다 보니 카프카 처럼 내결함성이 있고 확실히 처리가 가능한 큐를 사용하려 하고 있다. 
 아이템 지급이 지속적으로 지연이 발생하면 해당 파드만 Scale Up 하는 등 필요한 부분만 효율적으로 자원을 할당할 수 있다. 

![이미지](/assets/images/Pasted%20image%2020260225095020.png)

카프카를 사용하는 예시인데.. 만약 단일 파티션 단일 아이템 지급 컨슈머 서비스하다가 서비스 인기가 많아져서 아이템 지급건수가 늘어나고 토픽 LAG가 계속 쌓인다면 파티션을 확장 & 리밸런싱 후 아이템 지급  컨슈머를 늘려서 아이템 지급 컨슈머 부분만(필요한 부분만) 유동적으로 확장이 가능해 질 것이다.

![이미지](/assets/images/Pasted%20image%2020260225095027.png)

SQS 와 같은 큐를 사용한다면 KEDA(Kubernetes Event Driven Autoscaler)를 사용하고 싶다.
LAG(마지막 offset 번호 - commit 완료 offset) 이 특정 수치를 넘어가면 작업 큐가 좀처럼 빠지지 않는 것이므로 Pod Scale up을 통해 작업 처리에 자원을 더 할당하는 식으로 “우아하게” 대응이 가능할 것 같다.
  - 물론 멱등처리는 기본이다!
