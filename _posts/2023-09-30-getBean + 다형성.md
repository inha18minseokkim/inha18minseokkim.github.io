---
title: getBean + 다형성
date: 2023-09-30
tags:
  - Spring
  - 개발
---
문제 상황 - EssentialWriter라는 인터페이스를  상속하는 다양한 Writer들.. 해당 Writer는 각각 하나의 @Repository를 가진 빈을 멤버 변수로 갖고 있음(extends JPARepository).

해야하는 일 - enum에 등록되어있는 Class Type을 getBean해야 함
방법이 여러가지라 뭐가 좋은방법인지…고민중
getBean해야 하는 클래스는 다음과 같음

```java
@RequiredArgsConstructor
@Service
public class PaidIncreaseWriter implements EssentialWriter{
    private final AnnouncePaidIncreaseRepository announcePaidIncreaseRepository;
    @Override
    public Integer save(EssentialReport essentialReport) {
        AnnouncePaidIncrease announcePaidIncrease = (AnnouncePaidIncrease) essentialReport;
        AnnouncePaidIncrease save = announcePaidIncreaseRepository.save(announcePaidIncrease);
        return 1;
    }
}
```

앞으로 EssentialWriter를 구현하는 빈은 계속 늘어날 예정(20개 정도)

getBean을 그대로 하자

```java
public Integer saveRepository(Stream<? extends EssentialReport> stream, AnnounceKindCode announceKindCode) {
        //스프링 컨테이너 생성
        ApplicationContext applicationContext = ApplicationContextProvider.getApplicationContext();
        //announceKindCode에 있는 EssentialWriter 타입 빈 로딩
        log.info(announceKindCode.getEssentialWriter().toString() + " 빈 호출");
				//class type으로 getBean
        EssentialWriter essentialWriter = applicationContext.getBean(announceKindCode.getEssentialWriter());
        //각각의 스트림 저장
        return stream.map((essentialReport -> essentialWriter.save(essentialReport)))
                .reduce(Integer::sum).orElse(0);
    }
```

이슈 - getBean쓰지 마라.
[https://stackoverflow.com/questions/812415/why-is-springs-applicationcontext-getbean-considered-bad](https://stackoverflow.com/questions/812415/why-is-springs-applicationcontext-getbean-considered-bad)

해시맵에 박아놓고 하자
[https://stackoverflow.com/questions/48883984/alternative-to-applicationcontext-getbean-in-spring](https://stackoverflow.com/questions/48883984/alternative-to-applicationcontext-getbean-in-spring)

```java
public class APIHandler {

    @Autowired
    private Map<String, SomeInterface> impls;

    public ResponseEntity post(@RequestBody HandlingClass requestBody) {
        String beanName = "..."; // resolve from your requestBody        
        SomeInterface someInterface = impls.get(beanName);
        someInterface.doSomething();
    }
}
```

이런식으로 맵으로 세팅해놓고 받아옴

```java
// qualifier can be omitted, then it will be "UseClass1" by default
@Service("beanName1") 
public class UseClass1 implements SomeInterface { } 

// qualifier can be omitted, then it will be "UseClass2" by default
@Service("beanName2")
public class UseClass2 implements SomeInterface { }
```

실제로는 이렇게 해놓음

그냥 2번으로 하기로 함
[getBean을 하지마라?]({% post_url 2023-10-01-getBean을 하지마라 %})
