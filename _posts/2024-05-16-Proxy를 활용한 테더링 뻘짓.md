---
title: "데이터 소진 후 안드로이드 프록시 서버로 테더링 뻘짓"
date: 2024-05-16
tags:
  - 개발
  - 네트워크
  - 뻘짓
---

맥북 + 테더링 또는 서피스 + 데이터쉐어링을 사용하는 도중 데이터가 소진되어 버리면 테더링을 할 수 없게 된다. 예를들면 매일 2기가 리필 + 소진시 3mbps 속도제한 무제한 요금제라면 하루 2기가를 부주의로 다 써버린다면 맥북과 서피스는 데이터를 쓰지 못하게 되는 것.

좌절하다가 그럼 누군가가 안드로이드 폰에 프록시 서버를 만들어서 통신사로 휴대폰 IP를 사용해서 릴레이 해주는 기능을 만들지 않았을까 하는 방법에 찾아봤다. 물론 프록시를 사용하다 보니 뒷단의 서피스의 IP가 통신사로 전달되지는 않지만 이상 패턴이 탐지되면 통신사에서 뭐라고 할 수도 있으므로 비상시에 사용하는걸로 하자..

![이미지](/assets/images/Pasted%20image%2020260223140450.png)

어차피 유동IP이므로 가리지 않겠다.

안드로이드 휴대폰의 경우 누군가가 Android Proxy Server 앱을 만들어서 플레이스토어에 배포해놨다. 행내에는 WIPS가 설치되어 있어 무선 테더링의 경우 재밍되기 때문에 유선 테더링으로 휴대폰과 서피스를 연결한다.

웹페이지는 HTTP/HTTPS를 사용하고 스프링 부트 - RDB 연결 같은것은 TCP 를 사용하기 때문에 HTTPS/HTTP Proxy 서버와 Socks5 Proxy 서버를 둘 다 켜주면 된다.

즉 이제 서피스에서 HTTP통신을 사용하려면 `192.168.21.34:1234` 휴대폰 서버1로, TCP 통신을 사용하려면 `192.168.21.34:1088` 휴대폰 서버2로 통신하면 된다.

![이미지](/assets/images/Pasted%20image%2020260223140455.png)

PC 카카오톡의 경우도 HTTP 프록시 서버 사용할 수 있다. 우선 HTTP 포트를 지정해놨는데 소켓포트를 열어놓았더니 1088로도 패킷이 들어오는것을 알 수 있었다.

![이미지](/assets/images/Pasted%20image%2020260223140500.png)

윈도우의 경우도 프록시 서버를 기본으로 설정할 수 있게 해놨는데 아직 이유는 잘 모르겠는데 포트를 socks5로 설정하면 연결이 끊긴다. 아마 SSL 문제일것같은데 좀 더 알아봐야할듯.

![이미지](/assets/images/Pasted%20image%2020260223140504.png)

인텔리제이의 경우 JVM 옵션으로 프록시 서버를 세팅해줄 수 있다. JDBC가 TCP 통신을 사용하므로 SOCKS5 포트 설정해주면 된다.

![이미지](/assets/images/Pasted%20image%2020260223140509.png)

git을 사용하는 경우 `.git config`에 적어주거나 global config 세팅해주면됨

즉 해당 프로세스가 외부와 통신할 때 프록시 서버를 설정할 수 있으면 해당 서버를 바로 찌른다.

![이미지](/assets/images/Pasted%20image%2020260223140513.png)

이런식으로 포워드 프록시 방법을 사용함.

---

### 궁금했던점

프록시 서버를 지정하면 요청을 보내는쪽에서 포워딩하는 정보도 담아줄까?
당연히 담아주겠지만 TCP 레이어와 HTTP 레이어 어디에다가 담아줄까?

## SOCKS5 프로토콜 터널링

클라이언트가 프록시 서버에 연결함 (예: `192.168.21.34:1088`)

연결이 되면, 클라이언트가 프록시 서버에게 말함:

> "나 example.com:5432 에 연결하고 싶어"

프록시 서버는 이걸 받아서 새 TCP 커넥션을 열어서 `example.com:5432` 에 대신 연결하고, **클라이언트 ↔ 프록시 서버 ↔ 최종 서버** 트래픽을 중계해줌.

즉 SOCKS5의 경우 TCP Handshake 시 특정 호스트로의 포워딩을 먼저 요청하고 핸드쉐이크 성공하면 해당 파이프라인으로 신호를 밀어넣는 구조. 즉 TCP Dump 떠보면 처음에는 포워딩 요청해주고 그후의 터널에서는 호스트 정보가 나오지 않을 것.

```
1. TCP 연결 수립
[Client] -> [SOCKS5 Proxy]

2. 인증 협상
[Client] <-> [Proxy]

3. 목적지 요청
"example.com:5432로 연결해주세요!"

4. 프록시가 최종 서버에 연결

5. 연결 완료
[Client] <-> [Proxy] <-> [example.com:5432]

(이후 그냥 데이터 터널링)
```

## HTTP 프록시 방식 (특히 `CONNECT`)

**HTTP 프록시** (CONNECT 안 쓸 때)는 요청마다 목적지와 경로가 다 노출됨. 평문 HTTP라면 요청 메소드(GET/POST), Host 헤더, URI, 바디 내용이 다 그냥 보임.

**HTTP CONNECT**는 CONNECT 요청만 평문으로 보이고, 연결 완료 이후는 터널 안에서 암호화된 트래픽이 지나감 (특히 HTTPS인 경우). 즉, CONNECT 요청은 평문이고, 그 이후 트래픽은 볼 수 없음.

```
1. TCP 연결
[Client] -> [HTTP Proxy]

2. CONNECT example.com:443 요청
[Client] --> [Proxy]

3. 프록시가 목적지 TCP 연결
[Proxy] --> [example.com:443]

4. 연결 완료
[Client] <-> [Proxy] <-> [example.com:443]

(그 다음부턴 그냥 데이터 주고받음)
```

## 실제 흐름 (덤프에 찍히는거)

**HTTP 프록시 (CONNECT 없는 경우):**

```
GET http://example.com/index.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 ...
```

**HTTP 프록시 (CONNECT 사용하는 경우):**

```
CONNECT example.com:443 HTTP/1.1
Host: example.com:443

(이후 SSL/TLS 핸드쉐이크 → 암호화된 데이터)
```

## SOCKS5 vs HTTP CONNECT 비교

| 항목 | SOCKS5 | HTTP CONNECT |
|------|--------|--------------|
| 초기 협상 | 있음 (인증 방식 협상) | 없음 (바로 CONNECT 요청) |
| 목적지 전달 | 바이너리 프로토콜로 전달 | HTTP 요청으로 전달 |
| 주 사용 케이스 | DB, 다양한 프로토콜 트래픽 | 주로 HTTPS 프록시용 (웹) |
| 지원하는 명령 | CONNECT, BIND, UDP ASSOCIATE 등 다양 | CONNECT만 (터널용) |

## tcpdump 로 캡쳐했을 때

| 구분 | 설명 |
|------|------|
| TCP 연결하는 호스트 정보 | TCP 레벨에서 보인다 (패킷의 IP 주소/포트) |
| 최종 요청하는 목적지 (ex. example.com) | HTTP 페이로드 안에 보인다 (Host 헤더, 요청라인) |

당연히 HTTP레이어에서는 프록시 서버에 대한 정보가 보이지 않는다. 어디로 요청을 보내는지에 대한 정보는 TCP 레이어에 있기 때문.

> "tcpdump로 보면 TCP 연결은 프록시 서버로, HTTP 페이로드 안에는 최종 목적지 서버 정보가 들어 있다."

### 1. TCP 연결 (거쳐가는 프록시 정보)

`tcpdump`로 보면 가장 먼저 보이는 건 TCP 3-way handshake:

```
Client_IP.12345 > 192.168.1.100.3128: Flags [S]
192.168.1.100.3128 > Client_IP.12345: Flags [S.]
Client_IP.12345 > 192.168.1.100.3128: Flags [.]
```

여기서 클라이언트가 `192.168.1.100:3128` (프록시 서버)로 TCP 연결했다는 걸 알 수 있음. 프록시를 거친다는 정보는 이 TCP 연결 대상이 프록시라는 걸 아는 것으로만 판단 가능. 당연히 HTTP레이어에서는 알 수 없음.

### 2. HTTP 요청 (실제 요청지 정보)

그 다음에 나온 HTTP 데이터 패킷을 보면:

```
GET http://example.com/index.html HTTP/1.1
Host: example.com
User-Agent: curl/7.68.0
Accept: */*
```

프록시는 없고 실제 타겟지가 보임.
