---
title: "빌더 패턴"
date: 2023-09-04
tags: [미지정]
---


## 기존 생성자 문제점

변수가 너무 많아 생성자 코드가 너무 복잡하고 커진다 → 체이닝 패턴 써

```java
class Fake {
    private int a;
    private int b;
    private int c;
    public Fake(int a){
        this.a = a;
        this.b = 0;
        this.c = 0;
    }
    public Fake(int a,int b){
        this(a);
        this.b = b;
    }
    public Fake(int a,int b,int c){
        this(a,b);
        this.c = c;
    }
}
```

문제 - 얘는 코드 중복을 줄였지만 어쨌든 호출할 때  변수가 너무 많으면  ㅈㅈ
→  빈 생성자 만들어서 거기다가 set ㄱㄱ(현 케뱅에서 하는 방법, 빌더를 쓰고 싶어도 BXM 프레임워크에서 omm java 소스 수정하지 마라해서 못씀) → 문제는 빈 생성자를 구현한 다음에 set을 하는 경우 DTO 객체가 의도치 않은 패턴의 데이터를 가질 수 있음 + immutable하게 구현할 수 없음 (javascript에서 freezing이라는 기법이 있지만 자바는 없음)
→ 이럴 때 빌더를 고려해보자

```java
package com.example.test;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.SpringBootApplication;

class Muyaho {
    private int a;
    private int b;
    private int c;
    public Muyaho(){}
    private Muyaho(MuyahoBuilder builder){
        this.a = builder.a;
        this.b = builder.b;
        this.c = builder.c;
    }
    
    public static class MuyahoBuilder {
        private int a;
        private int b;
        private int c;
        public MuyahoBuilder a(int a){
            this.a = a;
            return this;
        }
        public MuyahoBuilder b(int b){
            this.b = b;
            return this;
        }
        public MuyahoBuilder c(int c){
            this.c = c;
            return this;
        }
        public Muyaho build(){
            return new Muyaho(this);
        }
        
    }
    
}
@SpringBootApplication
public class TestApplication {
    private final static Logger log = LoggerFactory.getLogger(TestApplication.class);

    public static void main(String[] args)  {
        Muyaho muyaho = new Muyaho.MuyahoBuilder().
                a(1).
                b(2).
                c(3).
                build();
        
    }
}
```


## 장점

생성자에 파라미터가 과도하게 들어가는것 방지

## 단점

코드가 복잡함. 일반 생성자와 다르게 다른 개발자의 코드를 알아보기가 힘듬
→ 그래서 lombok을 사용할 수 있음@Builder → 문제는 현재 lombok의 경우 필수적으로 들어가야 하는 멤버의 셋팅을 할 수없음. 그냥 빈 생성자에서 부터 시작해야 함.
그러므로 파라미터가 복잡해지면 빌더를 고려해보자.정도


```java
public abstract class Pizza{
	public enum Toping {HAM,SAUSAGE,ONION,PEPPER,SAUSAGE}
	final Set<Topping> toppings;

	abstract static class Builder<T extends Builder<T>> { //재귀적인 타입제한 사용
																				//해당 빌더가 해당 클래스 하위 타입의 빌더만 받도록
		EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);
			
		public T addTopping(Topping topping){
			toppings.add(Objects.requireNonNull(topping));
			return self();//this를 리턴하는 경우 Pizza.Builder를 리턴하게 됨. 
										//그럼 하위 상속받는 클래스들은 
										//항상 자신의 타입으로 캐스팅을 해줘야 함.
		}

		abstract Pizza build();
		protected abstract T self();
	}
	Pizza(Builder<?> builder) {toppings = builder.toppings.clone();}
}
```


```java
public class NyPizza extends Pizza {
	public enum Size { SMALL,MEDIUM,BIG }
	private final Size size;

	public static class Builder extends Pizza.Builder<Builder> {//여기서 <Builder>의 Builder는 자기자신임(NyPizza.Builder). 
																															//(상위 Pizza를 상속한) NyPizza의 Builder
		private final Size size;
		public Builder(Size size) { this.size = Objects.requireNonNull(Size); }

		@Override public NyPizza build() { return new NyPizza(this); }
		@Override protected Builder self() { return this; }
	}
	private NyPizza(Builder builder) {
		super(builder);
		size = builder.size;
	}
	@Override public String toString() { return toppings + "로 토핑한 뉴욕피자"; }
}
```

하위 타입으로 리턴할 수 있게 해놓지 않고 Builder<T> 로 지정한다면 NyPizza.Builder를 호출했는데 Pizza 객체가 빌드되는 결과 생김(Generic 다시 한번 봐야할듯)

```java
public class Calzone extends Pizza {
	private final boolean sauceInside;
	
	public static class Builder extends Pizza.Builder<Builder> {
		private boolean sauceInside = false;
		
		public Builder sauceInside() {
			sauceInside = true;
			return this;
		}
		@Override public Calzone build() { return new Calzone(this); }
		@Oberride protected Builder self() { return this; }
	}
	private Calzone(Builder builder) {
		super(builder);
		sauceInside = builder.sauceInside;
	}
	@Override public String toString() {
		return String.format("%s로 토핑한 칼초네 피자");
	}
}
```

