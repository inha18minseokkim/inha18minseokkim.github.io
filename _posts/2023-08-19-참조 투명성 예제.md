---
title: "참조 투명성 예제"
date: 2023-08-19
tags: [미지정]
---

```java
double d1 = 3.14;
double d2 = d1;
Double o1 = d1;
Double o2 = d2;
Double ox = o1;
System.out.println(d1 == d2 ? "Y" : "N"); //Y
System.out.println(o1 == o2 ? "Y" : "N"); //N
System.out.println(o1 == ox ? "Y" : "N"); //Y
```

객체의 경우 equals를 사용하지 않으면 당연히 안됨. 객체형 아닌 기본형을 줬음에도 불구하고
컴파일러 단에서 객체의 경우 자연스레 기본형 비교를 사용하지 않고 참조형을 사용함. ⇒ 주소값이 달라지면 다른 객체로 인식

따라서

참조투명성 문제 생김 : 참조 투명성을 달성하기 위해 기존의 객체를 변형시킨 결과를 리턴하지 않고 새로운 결과를 리턴 하는 경우, 사람이 봤을 때 구조적으로 같은 객체이지만(내부 값은 같음) 주소값이 달라 엄밀하게 멱등하지 않다고 판단..
but 그런것까지 일일이 따지지 말고 내부 구조적으로 같은 객체면 같다고 판단하도록 하자.
