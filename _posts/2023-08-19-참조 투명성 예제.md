---
title: "참조 투명성 예제"
date: 2023-08-19
tags: [미지정]
---

```java
double d1 = 3.14;
double d2 = d1;
Double o1 = d1;
Double o2 = d2;
Double ox = o1;
System.out.println(d1 == d2 ? "Y" : "N"); //Y
System.out.println(o1 == o2 ? "Y" : "N"); //N
System.out.println(o1 == ox ? "Y" : "N"); //Y
```

객체의 경우 equals를 사용하지 않으면 당연히 안됨. 객체형 아닌 기본형을 줬음에도 불구하고
컴파일러 단에서 객체의 경우 자연스레 기본형 비교를 사용하지 않고 참조형을 사용함. ⇒ 주소값이 달라지면 다른 객체로 인식

따라서

참조투명성 문제 생김 : 참조 투명성을 달성하기 위해 기존의 객체를 변형시킨 결과를 리턴하지 않고 새로운 결과를 리턴 하는 경우, 사람이 봤을 때 구조적으로 같은 객체이지만(내부 값은 같음) 주소값이 달라 엄밀하게 멱등하지 않다고 판단..
but 그런것까지 일일이 따지지 말고 내부 구조적으로 같은 객체면 같다고 판단하도록 하자.

---

### 참조 투명성이란

어떤 표현식을 그 평가 결과로 대체해도 프로그램 동작이 바뀌지 않는 성질.
쉽게 말해 **같은 입력 → 항상 같은 출력, 부수효과 없음**.

```java
// 참조 투명한 함수
int add(int a, int b) { return a + b; }
// add(1, 2)는 언제 어디서 호출해도 3. 3으로 대체 가능.

// 참조 투명하지 않은 함수
int counter = 0;
int increment() { return ++counter; } // 외부 상태에 의존 → 호출할 때마다 다른 값
```

함수형 프로그래밍에서 중요한 이유 : 함수를 값처럼 다루려면(변수에 저장, 인자로 전달 등) 그 함수가 언제 어디서 실행돼도 동일하게 동작한다는 보장이 필요함. 참조 투명성이 없으면 그 보장이 깨짐.

---

### 동일성 vs 동등성

위의 `o1 == o2`가 N인 이유를 좀 더 명확히 정리하면

- **동일성 (Identity, `==`)** : 같은 메모리 주소를 가리키는지. 참조 비교.
- **동등성 (Equality, `equals`)** : 내부 값이 구조적으로 같은지. 내용 비교.

`Double o1 = d1`과 `Double o2 = d2`는 같은 3.14를 담고 있지만 각각 별도로 boxing되어 다른 객체가 생성됨. 그래서 `==`는 false.

반면 `Double ox = o1`은 같은 참조를 복사한 것이므로 `o1 == ox`는 true.

---

### 불변 객체와의 관계

참조 투명성을 지키려면 함수가 **기존 객체를 변형하지 않고 새 객체를 반환**해야 함.
그런데 새 객체를 반환하면 위처럼 참조가 달라지는 문제가 생김.

여기서 필요한 게 불변 객체(Immutable Object). 불변 객체는 생성 후 내부 상태가 바뀌지 않으니까 같은 값이면 같다고 봐도 무방함. 그러려면 `equals`와 `hashCode`를 값 기반으로 재정의해야 함.

Java에서 `String`, `Integer` 등이 불변인 이유도 이것. 값이 같으면 같은 것으로 취급하는 **value semantics**를 가지도록 설계됨.

---

### Java record로 해결하기

Java 14부터 나온 `record`는 이 보일러플레이트를 자동으로 처리해 줌.

```java
// record: equals, hashCode, toString 자동 생성 + 불변
record Point(double x, double y) {}

Point p1 = new Point(3.14, 2.71);
Point p2 = new Point(3.14, 2.71);

System.out.println(p1 == p2);     // false (여전히 다른 참조)
System.out.println(p1.equals(p2)); // true  (값 기반 비교, 자동 생성)
```

일반 클래스라면 `equals`/`hashCode`를 수동으로 재정의해야 하고 빠뜨리기 쉬움. record는 모든 필드를 기반으로 자동 생성해줌.

결국 포스팅 맨 앞 예제의 결론 — "내부 구조적으로 같은 객체면 같다고 판단하자" — 를 제대로 구현하려면 `equals` 재정의가 필수고, record가 그걸 자동으로 해결해 준다.
