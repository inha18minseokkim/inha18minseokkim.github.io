---
title: "언럭키 CQRS 패턴 (20251010)"
date: 2025-10-10
tags: [아키텍처, CQRS, Spring, 백엔드, 주식서비스]
---

업무에서 어쩌다보니 CQRS 패턴에 가까운 구조가 되어버렸다.

**ASIS)**

기존 ipo-service 구조에서 읽기와 쓰기가 같은 레이어를 타고 있었다. PM 일정이 빡빡하다보니 개선 계획 없이 기능이 붙어나가면서...

**TOBE)**

그러다보니 궁극적으로 자연스럽게 CQRS에 가까운 구조가 되어버렸다.

---

## CQRS 패턴에 대한 설명

> CQRS(Command Query Responsibility Segregation)는 명령(Command)과 조회(Query)의 책임을 분리하는 아키텍처 패턴이다.

- **Command** = 시스템의 상태를 변경하는 작업 (Create, Update, Delete)
- **Query** = 시스템의 상태를 조회하는 작업 (Read)

CQRS의 핵심은 이 두 가지를 명확하게 분리해서, 각각 최적화된 모델을 사용하는 것이다.

조회 성능을 위해 Read DB를 따로 운영하거나, 쓰기 처리량을 높이기 위해 Write 경로만 최적화하는 것이 가능해진다.

---

## 향후 주식서비스 개선

Aurora 마스터-슬레이브 구조를 활용해서:

- **Write**: Master DB로만 라우팅
- **Read**: Slave(Read Replica)로 라우팅

### 성능 관점 최적화

I/O 분리 및 이벤트 기반 구조로 개선하면:

- 읽기 요청이 많은 주식 시세 조회 → Read Replica로 분산
- 데이터 변경 이벤트 발행 → 이벤트 기반 캐시 갱신
- 쓰기 성능에 영향 없이 읽기 처리량 수평 확장 가능

---

어쩌다 보니 CQRS를 구현하게 된 케이스인데, 이런 식으로 자연스럽게 패턴이 생겨나는 경우가 많은 것 같다. 처음부터 CQRS를 설계 목표로 잡기보다, 읽기/쓰기 요구사항이 달라지는 시점에 분리를 고민하는 게 현실적인 것 같다.
