---
title: 함수형 프로그래밍
date: 2023-08-19
tags:
  - Java
  - 개발
---

### 공유된 가변 데이터의 문제 - 유지보수

여러 클래스에서 가변 자료구조를 공유하게 된다면 해당 자료가 어느 클래스 소유인지 불분명하게 됨. + race condition 문제 생길 수 있음. 해결하기 위해 “공유””가변” 데이터에 synchronized를 사용한다면 재앙의 시작이 될 수도 있음

### 부작용

자료구조를 고치거나 필드에 값을 해당
예외 일으킴
File I/O
세 가지의 경우 race condition을 일으킬 수 있음

### 영속 자료구조

함수형 자료구조, 불변 자료구조
참조 투명성을 위배하면 안됨. 파괴적인 갱신을 당하면 안됨.

```java
class TrainJourney {
	public int price;
	public TrainJourney onward;
	public TrainJourney(int p, TrainJourney t) {
		price = p;
		onward = t;
	}
}

static TrainJourney link(TrainJourney a, TrainJourney b) {
	if(a==null) return b;
	TrainJourney t = a;
	while(t.onward != null) {
		t = t.onward;
	}
	t.onward = b;
	return a;
}
```

이런식으로 호출을 하면 a,b를 넣어 → 바뀐 a를 만들어버림

```java
static TrainJourney append(TrainJourney a, TrainJourney b) {
	return a == null ? b : new TrainJourney(a.price, append(a.onward, b));
}
```

이렇게 하면 기존 a는 바뀌지 않고 b와 연결된 새로운 a를 재귀적으로 생성
“결과 자료구조를 바꾸지 말자”


### 선언형 프로그래밍 vs 함수형 프로그래밍


```java
Transaciton mostExpensive = transactions.get(0);
if(mostExpensive == null)
	throw new IllegalArgumentException("Empty list of transactions");
for(Transaction t : transactions.subList(1, transactions.size()) {
	if(t.getValue() > mostExpensive.getValue()) {
		mostExpensive = t;
	}
}
//선언형 외부반복. 어떻게 해당 문제를 푸는것인지 집중. 컴퓨터의 저수준 언어와 비슷
```


```java
Optional<Transaction> mostExpensive = transactions.stream()
.max(comparing(Transaction::getValue));
//함수형 내부반복. 무엇을 풀어야 하는지에 집중. 나름 고수준(가독성 좋음)
```


### 일급함수

일반값으로 취급할 수 있는 함수 → 일급함수. 
멱등성,불변성을 보장하면 되는 것. 동일 input → 동일 output. 말 그대로 함수와 동일
but, 실제 프로그램에서는 보장하기 힘듬. ex)알고리즘 문제를 풀 때 특정 함수를 호출 시 scope 밖의 전역의 변수나 자료구조를 참조하여 input 과 output시의 state가 달라져버리면 다음 호출에도 영향을 받음. 
stream을 타는 파이프라이닝 함수의 경우 stateful한 경우 문제가 있을 수 있다.

![이미지](/assets/images/Pasted%20image%2020260224084820.png)

딱 이렇게만 나와야 한다. 중간에 새거나 다른 유출입이 있으면 안됨.
따라서 정확한 함수형인 경우 예외도 허용하지 않음 ⇒ Optional<>을 사용하여 바인딩

### 고차원함수

하나 이상의 함수를 인수로 받음
함수를 결과로 변환
ex) 미분을 하는 함수, f(x) = x^2을 Function<Function<Double,Double>, Function<Double,Double>> 의 형식을 통해 f’(x) = 2x로 변환시키는 함수


## static 함수형 인터페이스


```java
package com.example.test;

import lombok.Getter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;


class Muyaho {
    public Muyaho(int a) {this.a = a;}
    int a;
    public int compareByA(Muyaho aa, Muyaho bb){
        return aa.a - bb.a ;
    }
    public static int compareByAStatic(Muyaho aa, Muyaho bb){
        return aa.a - bb.a ;
    }

    public int compareByASingle(Muyaho bb){
        return this.a - bb.a;
    }
}
@SpringBootApplication
public class TestApplication {

    public static void main(String[] args)  {
        Muyaho a = new Muyaho(1);
        Muyaho b = new Muyaho(2);
        List<Muyaho> arr = new ArrayList<>();
        arr.add(new Muyaho(3));
        arr.add(new Muyaho(4));
        arr.add(new Muyaho(5));
        arr.add(new Muyaho(6));
        Comparator<Muyaho> tempComparator = Muyaho::compareByAStatic; //comparator로 추정가능
        tempComparator = Muyaho::compareByASingle;
        arr.sort(Muyaho::compareByAStatic);//static인 경우 인스턴스 선언안해도 바로 함수형 인터페이스 가능
        arr.sort(Muyaho::compareByASingle);//static은 아니지만 시그니처를 통해 배열의 각 원소가 this가 되어 다른 원소 비교
        arr.sort(a::compareByA); //전혀 쓸모는 없는 a는 그냥 객체싸개인 상황

    }
}
```


### 자바의 참조 투명성

참조 투명성 → 동일 input ⇒ 동일 output
자바의 문제 : 어디까지를 참조 투명성으로 봐야할 것인가? 
[참조 투명성 예제]({% post_url 2023-08-19-참조 투명성 예제 %})