---
title: "플라이웨이트 패턴"
date: 2023-08-31
tags: [미지정]
---
같은 객체가 자주 사용되는 경우 → 어딘가에 사용해놨다가 재사용 & 캐싱
객체를 가볍게 만들어 메모리 사용을 줄인다.
자주 변하는 속성과 변하지 않는 속성을 분리하고 재사용하여 메모리 사용을 줄임
FlyWeight Factory에서 변하지 않는것들을 갖다 넣어놓고 꺼내서 쓰는 형식. 

```java
public class Character{
	private char value;
	private String color;
	private String fontFamily;
	private int fontSize;

	public Character(char value, String color, String fontFamily, int fontSize) {
		this.value = value;
		this.color = color;
		this.fontFamily = fontFamily;
		this.fontSize = fontSize;
	}
}
```

TOBE

```java
public class Character{
	private char value;
	private String color;
	private String fontFamily;
	private Font font; //자주 쓰고 중복되는것 묶어 일단

	public Character(char value, String color, Font font) {
		this.value = value;
		this.color = color;
		this.font = font;
	}
}

public class FontFactory{
	private Map<String, Font> cache = new HashMap<>();
	public Font getFont(String font){
		if(cache.containKey(font)){
			return cache.get(font);
		} else {
			String[] split = font.split(":");
			Font newFont = new Font(split[0], Integer.parseInt(split[1]);
			cache.put(font,newFont);
			return newFont;
	}
}
```

이런식으로 미리 FontFactory에서 가져다 쓸 수 있음

# 사용예시(실무)

비슷한 패턴이라 정리는 해놓음(사내 프로젝트라 코드를 옮겨올 수는 없음). 해당 플라이웨이트 패턴 글을 보기 전에 혼자 고민했던 내용이라 위 내용과 다소 괴리가 있을 수 있음
상황 : 
각 고객별로 푸시 메세지 내용을 조합해서 보내야 하는 상황
하락 품목 3개, 예시 3개, 템플릿 5개 하루 45개의 조합이 가능, 해당 조합을 고객별 랜덤 발송
초기에는 빨리 내야해서 Spring batch에서 푸시대상 고객 DTO 마다 일일이 db에서 하락 품목을 로딩해서 가져다 주는 방식을 사용
문제점 : 
DB를 각 고객마다 타므로 푸시 2만건을 보내려고 할 때 문제가 생길 수 있다는 생각이 들었음
해결 : 
푸시 조합을 계산하여 distinct 걸어보니 하루 총 14개 내외로 조합이 나왔기 때문에 DB태우는 작업을 객체로 만들어 HashMap을 사용하여 캐싱처리 함
즉 DB IO를 하지않고 캐싱처리 해버림
배치로 수행되는 프로세스이기 때문에 @Business 사용하여(BXM프레임워크임. Service 어노테이션 같은 느낌) 싱글톤 컨텍스트 내에서 Hashmap 사용
결과적으로 2만건 UMS 테이블 적재에 20초 정도 걸리도록 수행.
