---
title: "Lazy init"
date: 2023-08-19
tags: [미지정]
---
Stream Supplier를 사용한 Lazy init

```java
package com.example.test;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.Optional;
import java.util.function.Predicate;
import java.util.function.Supplier;

interface MyList<T>{
    T head();
    MyList<T> tail();
    default boolean isEmpty() {
        return true;
    }
    //predicate받는 필터 함수 만듬
    default public MyList<T> filter(Predicate<T> p) {
        return isEmpty() ? this : p.test(head()) ? new LazyList<>(head(), () -> tail().filter(p)) : tail().filter(p);
    }
}

class MyLinkedList<T> implements MyList<T>{
    private final T head;
    private final MyList<T> tail;

    MyLinkedList(T head, MyList<T> tail) {
        this.head = head;
        this.tail = tail;
    }

    @Override
    public T head() {
        return head;
    }

    @Override
    public MyList<T> tail() { //tail을 바로 가져와야함
        return tail;
    }

    @Override
    public boolean isEmpty() {
        return false;
    }
}

class Empty<T> implements MyList<T>{

    @Override
    public T head() {
        throw new UnsupportedOperationException();
    }

    @Override
    public MyList<T> tail() {
        throw new UnsupportedOperationException();
    }
}

class LazyList<T> implements MyList<T> {
    final T head;
    final Supplier<MyList<T>> tail;
    private Optional<LazyList<T>> alreadyComputed;
    LazyList(T head, Supplier<MyList<T>> tail) {
        this.head = head;
        this.tail = tail;
    }

    @Override
    public T head() {
        return head;
    }

    @Override
    public MyList<T> tail() {
        return tail.get(); //Supplier를 통해 Lazy 동작 가능
    }

    @Override
    public boolean isEmpty() {
        return false;
    }
    public static <T> void printAll(MyList<T> list){
        if (list.isEmpty()) return;
        System.out.println(list.head());
        printAll(list.tail());
    }
}

@SpringBootApplication
public class TestApplication {
    private final static Logger log = LoggerFactory.getLogger(TestApplication.class);
    public static LazyList<Integer> from(int n){
        return new LazyList<Integer>(n, () -> from(n+1));
    }//재귀적으로 호출했지만 Lazy하게 호출됨.
    public static MyList<Integer> primes(MyList<Integer> numbers){
        return new LazyList<>(numbers.head(),
                () -> primes(
                    numbers.tail()
                            .filter(n -> n % numbers.head() != 0)
                )
        );
    }

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
        //그냥 링크드 리스트
        MyList<Integer> l = new MyLinkedList<>(5,new MyLinkedList<>(10,new Empty<>()));
        //Stream Supplier로 Lazy하게 구현된 링크드 리스트
        LazyList<Integer> numbers = from(2);
        int two = numbers.head();
        int three = numbers.tail().head();
        int four = numbers.tail().tail().head();
        System.out.println(two + "," + three + "," + four); //실제로 숫자는 요청했을 때 만들어짐
        //Lazy 필터 구현
        LazyList<Integer> primeNumber = from(2);
        int two2 = primes(primeNumber).head();
        int three3 = primes(primeNumber).tail().head();
        int five5 = primes(primeNumber).tail().tail().head();
        System.out.println(two2 + "," + three3 + "," + five5);

        //실제로 사용하면 stackoverflow 난다 일단 예제임
        LazyList.printAll(primes(primeNumber));

    }

}
```

LinkedList 같은 경우는 처음 init될 때 모두 메모리에 올라오지만 LazyList의 요소는 Function에서 찌를 때 차례로 init된다
