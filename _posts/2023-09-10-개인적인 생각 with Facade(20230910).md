---
title: 개인적인 생각 with Facade(20230910)
date: 2023-09-10
tags:
  - 개발
---
협업이든지 개발이든지 다 좋고 아무튼 개인적으로 느낀 점
stateless 할 수록 재사용성이 좋다(정확한 표현은 아님, 정확하게는 scalable과 유연성 관련되면 stateless한것이 좋다)
같은 레벨에서 호출하는것은 쉽지않다.
→ 그러므로 우리는 “짬통” 역할을 하는 무언가가 필요하다


### 가장 이상적이다고 생각하는 구조

![이미지](/assets/images/Pasted%20image%2020260224165954.png)

이런식으로 호출이 될 텐데 dependency 관계를 그려보면 Repository(DAO)가 가장 상위의 개념일 것이고, 그 다음이 서비스, 그 다음이 컨트롤러 이런식으로 될것임
다음과 같은 가정을 하고 그려본다 - dependency가 생기면 depth를 올린다
state가 있다면 가급적 최상위로 옮긴다
controller는 주고받는 로직만 넣자
그럼 대충 이런 느낌으로 트리가 만들어짐
![이미지](/assets/images/Pasted%20image%2020260224170001.png)

Repository,Service,Controller의 숫자는 그때그때 다르긴할건데 아무튼 
Service는 각 Repository의 조합, Controller는 각 Service의 조합으로 만들어질 것

가장 이상적인상황(본인이 느끼기에)이라고 생각하지만 현실적으로는 다음과 같은 제약이 있음
연결을 유지하거나 특정한 상태가 필요한 서비스
서비스의 상호호출
을 반영하여 다시 그려봄. 
아래는 1번을 반영한 그림
![이미지](/assets/images/Pasted%20image%2020260224170010.png)

stateful하거나 외부 네트워크를 타는(따지고보면 이것도 Stateful할 수 있다) 경우는 대체로 다른 서비스들이 방금 말한 서비스들에 의존할 것이므로 1depth 차이나지만 repository에 의존할 수 있으므로
2번을 반영한 그림
![이미지](/assets/images/Pasted%20image%2020260224170025.png)
서비스 A와 D는 B와 C를 호출하고 있기 때문에 1 depth 차이남. 위에서 서비스는 총 3 depth 차이가 나므로 생각보다 간단하게 표현할 수 있지만 계속 상호 참조한다면 depth가 무한으로 늘어나 영향도 파악이 안될듯

결국에 위 상황에 대한 교통정리를 담당할 무언가가 필요함. 그러니깐 짬통이 될 수 있음
위 상황을 해결할 솔루션은 크게 세 가지라고 생각
컨트롤러에서 서비스들의 조합을 한다 → 싫다
![이미지](/assets/images/Pasted%20image%2020260224170034.png)

나름 괜찮아보이는데 1. 컨트롤러에 너무 많은 영역의 일을 시키고 2. 그래서 컨트롤러가 짬통화 되어버림
서비스의 공통 Business를 잘 정의해서 추가적인 depth가 생기는 것을 최대한 자제한다

![이미지](/assets/images/Pasted%20image%2020260224170040.png)

그러니깐 여기서 자주호출되는 서비스를 잘 정리해놨다가 코드리뷰 같은곳에서 걸러야함(타협)
이 방법이 대부분 쓰는 방식일텐데 해당 도메인 업무 담당자가 업무에 대한 이해를 잘 해야함
Facade

![이미지](/assets/images/Pasted%20image%2020260224170054.png)

이런식으로 서비스 중간에 은닉계층을 하나 만들어서 상하위간 영향이 없도록 함
문제점 
코드중복 발생
개발 귀찮음

절충점을 찾아야지..

---

## 보충: 서비스 간 상호 호출이 왜 문제인가

### 순환 참조 (Circular Dependency)

Spring Boot 2.6 이후로는 순환 참조가 기본적으로 금지되었다. (`spring.main.allow-circular-references=false` 기본값)

```java
@Service public class OrderService {
    private final PaymentService paymentService; // PaymentService에 의존
}

@Service public class PaymentService {
    private final OrderService orderService; // OrderService에 의존 → 순환!
}
```

```
APPLICATION FAILED TO START
The dependencies of some of the beans form a cycle:
orderService -> paymentService -> orderService
```

순환 참조가 없더라도 서비스 간 호출 체인이 길어지면 강결합 문제가 생긴다.
하나를 고치면 연쇄적으로 다른 서비스가 다 영향받는다.

### 트랜잭션 경계 관리가 어려워진다

서비스 A에서 B를 직접 호출할 때 각자 `@Transactional`을 붙이면 경계가 뒤엉킨다.
"어디서 커밋이 일어나는지"를 추적하기 어렵고, `REQUIRES_NEW` 같은 옵션을 잘못 쓰면
A가 롤백돼도 B에서 한 작업은 그대로 남는 이상한 상황이 생긴다.

---

## 결국 Facade를 어떻게 제대로 쓸 것인가

### 핵심 원칙: Facade는 조합만 한다

Facade가 코드 중복으로 이어지는 이유는 Repository에 직접 접근하거나 도메인 로직을 직접 넣기 때문이다.

```java
// 나쁜 예: Facade가 Repository에 직접 접근 → 도메인 로직 중복
@Component
public class BadOrderFacade {
    private final OrderRepository orderRepository; // 직접 접근 금지

    public void placeOrder(PlaceOrderCommand cmd) {
        Order order = new Order(cmd); // 도메인 로직이 여기 있으면 중복 발생
        orderRepository.save(order);
    }
}

// 좋은 예: Facade는 Service 메서드를 순서대로 호출하는 역할만
@Component
@RequiredArgsConstructor
public class OrderFacade {
    private final OrderService orderService;
    private final PaymentService paymentService;
    private final InventoryService inventoryService;

    @Transactional // 트랜잭션 경계는 Facade가 담당
    public OrderResult placeOrder(PlaceOrderCommand command) {
        inventoryService.reserve(command.getProductId(), command.getQuantity());
        Order order = orderService.create(command);
        Payment payment = paymentService.process(order.getId(), command.getPaymentInfo());
        return OrderResult.of(order, payment);
    }
}
```

- **Service**: 자신의 Repository만 직접 의존, 단일 도메인 책임
- **Facade**: 여러 Service를 조합하는 역할만, Repository 직접 접근 금지

`@Service` 대신 `@Component`를 쓰는 팀도 있다. 의미상 "비즈니스 로직 담당자"가 아니라 "조합 담당자"임을 명시하기 위해.

### Facade에게 트랜잭션을 완전히 넘기는 패턴

하위 서비스에 `Propagation.MANDATORY`를 걸면 Facade의 `@Transactional` 없이 단독 호출 시 예외가 발생한다.
실수로 Facade를 우회하는 것을 막을 수 있다.

```java
@Service
public class OrderService {
    @Transactional(propagation = Propagation.MANDATORY) // Facade 트랜잭션 안에서만 실행 가능
    public Order create(CreateOrderCommand command) { ... }
}

@Component
public class OrderFacade {
    @Transactional // 여기서 트랜잭션 시작
    public OrderResult placeOrder(PlaceOrderCommand command) {
        // 하위 서비스들이 이 트랜잭션에 참여
        Order order = orderService.create(command);
        Payment payment = paymentService.process(order.getId(), command.getPaymentInfo());
        return OrderResult.of(order, payment);
    }
}
```

### 부가 기능은 이벤트로 분리

알림, 로그처럼 주요 흐름과 무관한 기능은 이벤트로 빼면 Facade가 비대해지는 것을 막을 수 있다.

```java
@Component
public class OrderFacade {
    private final ApplicationEventPublisher eventPublisher;

    @Transactional
    public OrderResult placeOrder(PlaceOrderCommand command) {
        Order order = orderService.create(command);
        eventPublisher.publishEvent(new OrderCreatedEvent(order.getId())); // 알림은 이벤트로
        return OrderResult.of(order);
    }
}

@Component
public class OrderNotificationHandler {
    // 트랜잭션 커밋 이후에 비동기로 실행 → 주문 저장 실패 시 알림이 나가는 문제 방지
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    @Async
    public void onOrderCreated(OrderCreatedEvent event) {
        notificationService.sendConfirmation(event.orderId());
    }
}
```

---

## 더 나아가면: DDD, Clean Architecture 방향

Facade 방식이 기본 해결책이라면, 도메인이 더 복잡해지면 DDD나 Clean Architecture 방향으로 가게 된다.

| 패턴 | 핵심 아이디어 | 어울리는 상황 |
|------|--------------|--------------|
| **Facade** | Service 위에 오케스트레이션 레이어 추가 | 일반적인 Spring 프로젝트, 빠른 개발 |
| **DDD Application/Domain Service 분리** | 순수 도메인 로직(인프라 무관) vs 유스케이스 흐름 분리 | 도메인 로직이 복잡하고 경계가 명확할 때 |
| **Clean Architecture Use Case** | 유스케이스 하나 = 클래스 하나, Port/Adapter로 인프라 분리 | 대규모 팀, 모듈 독립 배포 필요할 때 |
| **Event-Driven** | 직접 호출 대신 이벤트 발행/구독으로 결합도 최소화 | 비동기 처리, 부가 기능 분리 |

**현실적인 조합 권장안:**
- 기본: Facade (서비스 간 직접 호출 방지)
- 트랜잭션과 무관한 부가 기능: `@TransactionalEventListener` + `@Async`
- 도메인이 충분히 성숙했을 때: DDD 방식으로 점진적 전환

결국 "짬통"을 어디에 어떻게 만드냐의 문제이고, Facade는 그 중 가장 현실적인 출발점이다.
