---
title: getBean을 하지마라?
date: 2023-10-01
tags:
  - 개발
  - Spring
category: 기술
---
[https://stackoverflow.com/questions/812415/why-is-springs-applicationcontext-getbean-considered-bad](https://stackoverflow.com/questions/812415/why-is-springs-applicationcontext-getbean-considered-bad)
IOC 문제라 함
> the whole idea of Inversion of Control is to have *none of your classes know or care how they get the objects they depend on*.
그러니깐.. 대충 해석해서 요약해보면
getBean을 하는 행위는 특정 클래스에 강하게 의존할 수 있음
getBean으로 호출하는 서비스가 해당 클래스를 사용하면 호출되는 서비스에 의존됨
이게 복잡해지면 문제가 생김 → IOC 문제

다만 내가 쓰는 방법대로라면(특정 인터페이스 타입으로 객체를 받아 사용) 어떨까?!

```java
@Getter
public enum AnnounceKindCode {
    PAIDINCREASE("https://opendart.fss.or.kr/api/piicDecsn.json",AnnouncePaidIncreaseElement.class,
            AnnouncePaidIncrease.class, AnnouncePaidIncreaseMapper.class, PaidIncreaseWriter.class);
    /*호출 할 uri 저장*/
    String uri;
    /*response 시 list를 명세한 response객체*/
    Class<? extends EssentialResponseElement> responseClass;
    /*entity 사용 객체*/
    Class<? extends EssentialReport> entityClass;
    /*ResponseElement -> Entity 매핑 인터페이스 클래스 타입*/
    Class<?> mapperInterface;
    /*Repository 접근하는 EssentialWriter클래스*/
    Class<? extends EssentialWriter> essentialWriter;


    AnnounceKindCode(String uri, Class<? extends EssentialResponseElement> responseClass,
                     Class<? extends EssentialReport> entityClass, Class<?> mapperInterface,
                        Class<? extends EssentialWriter> essentialWriter) {
        this.uri = uri;
        this.responseClass = responseClass;
        this.entityClass = entityClass;
        this.mapperInterface = mapperInterface;
        this.essentialWriter = essentialWriter;
    }
}
```

이런식으로 Enum으로 클래스 타입을 선언해놓음(유상증자(PAIDINCREASE)이벤트에 필요한 클래스들 만들어놓음)

```java
public Integer saveRepository(Stream<? extends EssentialReport> stream, AnnounceKindCode announceKindCode) {
  //announceKindCode에 있는 EssentialWriter 타입 빈 로딩
  log.info(announceKindCode.getEssentialWriter().toString() + " 빈 호출");

  EssentialWriter essentialWriter = applicationContext.getBean(announceKindCode.getEssentialWriter());
	//EssentialWriter는 인터페이스. 인터페이스에서 명세한 메서드 대로 특정 동작들을 수행함.
  //각각의 스트림 저장
  return stream.map((essentialReport -> essentialWriter.save(essentialReport)))
          .reduce(Integer::sum).orElse(0);
  }
```

 그리고 실제 동작 비즈니스 함수에서 getBean호출

```java
@Service
public class PaidIncreaseWriter implements EssentialWriter {
    private final AnnouncePaidIncreaseRepository announcePaidIncreaseRepository;

    public PaidIncreaseWriter(AnnouncePaidIncreaseRepository announcePaidIncreaseRepository) {
        this.announcePaidIncreaseRepository = announcePaidIncreaseRepository;
    }

    @Override
    public Integer save(EssentialReport essentialReport) {
        AnnouncePaidIncrease announcePaidIncrease = (AnnouncePaidIncrease) essentialReport;
        AnnouncePaidIncrease save = announcePaidIncreaseRepository.save(announcePaidIncrease);
        return 1;
    }
}
```

실제 인터페이스를 주요사항보고서 → 유상증자 이벤트에 맞게 구현함

이러면 IOC를 지킬 수 있지않나..라는 생각이 들었음
실제로 그렇게 생각하시는 분도 계심(12년전 댓글이긴하지만..)
> • It's not true that ApplicationContext.getBean() is not IoC. Niether is it mandatory to have *all* your classes instantiated by Spring. That is inappropriate dogma. If the ApplicationContext is itself injected, then it's perfectly fine to ask it to instantiate a bean in this way - and the beans it creates can be different implementations based on the ApplicationContext initially injected. **For instance, I have a scenario where I dynamically create new bean instances based on a bean name that is unknown at compile time but matches one of the implementations defined in my spring.xml file.**
이런식으로 팩토리 느낌으로 .. 어차피 wire 할 때 스프링 컨텍스트에서 꺼내오는것
> i have the same issue, where a factory class will only know which bean or implementation to use at run time via user interaction, i think this is where the ContextAware interface comes in

아 물론 12년전이라 현재 스프링 부트랑은 많이 다름(xml을 사용하다보니 DI를 사용하면 다른 개발자가 이걸 파악하는데 오래걸린다고 하시거나..)
> Dependency injection is more suited to larger programs. Most of the time the additional complexity is not worth it.
지금과는 좀 많이 다른 스탠스가 보이긴한다.
> One of the coolest benefits of using something like Spring is that you don't have to wire your objects together. Zeus's head splits open and your classes appear, fully formed with all of their dependencies created and wired-in, as needed. It's magical and fantastic.

이 아저씨께서는 아마 wiring하고 빈 객체 관리 하는 장점을 사용하기 위해 스프링을 사용하는건데 굳이 이렇게 사용하면..스프링 쓰는 이유가 있나? 라고 이야기하심

아마 IOC 때문에 쓰지 말라는건 무분별한 getBean이 각 서비스 레이어간의 벽을 허물고(?) 격없는 소통을 하는것을 우려해서이기 때문인듯.

다만 나는 스프링 컨텍스트 내부에서 이런식으로 받는것도 괜찮다고 생각했는데..다른 더 좋은 방법이 있으면 찾아봐야할듯 하다.
