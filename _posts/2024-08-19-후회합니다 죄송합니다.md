---
title: "후회합니다 죄송합니다"
date: 2024-08-19
tags:
  - 개발
  - 아키텍처
  - Kafka
category:
  - 실무경험
---
MSA 구조에서 Pod/Project 분리 및 jflow 연동 과정에서의 설계 경험 정리.
![](https://prod-files-secure.s3.us-west-2.amazonaws.com/c38aebd7-2834-4fac-b2fc-a2f0c17ce81d/aa441752-e835-46bc-96e0-30ba5d9573fd/image.png)


비슷한 속성의 업무를 위하여 공통코드,모듈 분리
각 로직의 영향을 최소화 하기 위하여 Pod 단위 분리 (기존 MSA 정할때 규칙 그대로)
  - 원래는 한 프로젝트 안에서 다 넣고 > 배포하는 파드만 프로젝트 단위로 1: N 하려고 했는데 현재 그런 요건이 없음
  - 하나의 서비스가 다른 서비스(KafkaListener)가 다른 서비스 영향 주는것을 우려하여 파드를 내리고 올릴 때 쉽게 하기 위해 파드 분리
  - job(argo workflow)의 경우 최대한 껍데기를 빼고 기존 batch 를 사용하던 관행? 에서 그냥 단순 spring application 구동 후 0 리턴하는 형식으로 바꿈
    - 각 토픽마다 pod 하나씩.
      - pod 들은 특정 시간대에 jflow(케이뱅크 계정계 관제)를 통해 실행되고 메세지에 url과 관련 정보들은 pub 하면 open api(DBridge)에 물려있는 서블릿이 메세지를 sub하여 공중망으로 호출 후 응답부를 지정된 토픽으로 pub
      - 서비스들이 물고있는 토픽을 sub하여 데이터를 적재하든지 뭐든 함
간과한점
  - 케이뱅크 IT스퀘어에서 프로젝트 하나당 문서 하나, 즉 파드 하나를 만들 때 마다 변경계획담당(CHA), 개발(PKG) 문서 하나씩 추가되는 구조임
    - 이는 단위업무 하나당 프로젝트, 배포단위 하나인 MSA 구조와 맞지않는 설계인데 이걸 꾸역꾸역 맞추려고 하다보니 이사단이 난거긴 한데..
개선방향
  1. pod : project를 n:1 로 가능한 구조
  2. IT스퀘어에 신규 개발 해달라고 빌기
  3. 멀티모듈 만으로 스프링 프로젝트를 만들어놓고 dockerfile로만 배포하기
    - 이건좀;; 이렇게 하는곳은 없을듯



# 잠정 결론(20240909)

job : proejct 를 N : 1로 가져가는것이 맞을 듯 함.
배치 잡의 경우 jobName을 통해서 Bean 이름을 지정하면 해당 Bean이 뜨는 구조인데, 배치를 사용하지 않는 경우 수동으로 설정할 필요가 있음.

```java
spring.application.name=listed-stock-pub-job
EXTERNAL_HOST=125.176.39.143:29092
JOB_NAME: listedStockSeparatedAnnualProducer 
```

이런식으로 application.properties에 ApplicationRunner빈 이름을 넣어주고

```java
@Configuration
@RequiredArgsConstructor
public class SimpleApplicationJobConfig {
    private final ApplicationContext applicationContext;
    @Value("${JOB_NAME}")
    private String jobName;
    public ApplicationRunner applicationRunner {
        return (ApplicationRunner) applicationContext.getBean(jobName);
    }
}
```

이런식으로 빈을 주입하게 만들면 됨

```java
@RequiredArgsConstructor
@Component
public class ListedStockConsolidatedAnnualProducer implements ApplicationRunner {
    private final KafkaTemplate<String,Object> kafkaTemplate;
    @Value("${test}")
    private String test;
```

ApplicationRunner 빈 예시

### 위 방식의 문제점

모든 job이 공통 @Value가 있으면 상관없지만 공통으로 묶기 힘든 경우 문제가 생김.
  - ex) ApplicationRunnerA는 test1,test2 라는 파라미터가 필요하고 ApplicationRunnerB는 test3,test4라는 파라미터가 필요한 경우, @Value를 모두 선언해주고 넣어주거나 또는 null 위험에 노출됨
  - 왜냐하면 @Component를 모든 빈에다가 선언해야 getBean시 스캔된 빈을 가져올 수 있기 때문. 즉 getBean 하는 시점이 모든 빈이 만들어지는 시점 뒤임. 

### 대안


```java
@RequiredArgsConstructor
@Component
@ConditionalOnProperty(name = "JOB_NAME", havingValue = "listedStockConsolidatedAnnualProducer")
public class ListedStockConsolidatedAnnualProducer implements ApplicationRunner {
    private final KafkaTemplate<String,Object> kafkaTemplate;
    @Value("${test}")
    private String test;
```

@ConditionalOnProperty를 사용하여 Bean이 만들어 지기 전에 선택적으로 생성되게 하면 빈 생성 시점에 @Value 들만 체크하게 되고 나머지 Bean들은 무시함.
다만 단점은 어노테이션을 선언해줘야 하고 이름을 하드코딩해야한다 정도..?

아무튼 장애 리스크가 적은 정기작업이니깐.. jFlow에서 JOB_NAME 받아서 필요한 빈만 띄우면 괜찮지 않을까라는 개인적인 생각
2024.12. 1프로젝트에서 N 개의 정기작업을 띄울 수 있는 방법을 고안하여 SRE선생님께 전달드렸다

