---
title: "equals"
date: 2023-09-14
tags: [미지정]
---

### 필요 없는 경우

싱글톤일 경우
논리적 동치성을 검사할 필요가 없을 때
5천원 짜리 지폐가 같다 ⇒ value 비교하는  equals 선언해야됨
일련번호 다르고 구겨짐 다름 ⇒ 싹다 비교하는거면 안해도됨(주소값이 달라서 다른애)
상위 클래스에서 오버라이딩한 equals가 유효하면
private class라 호출될 이유가 없으면


### equals 규약

반사성
A.equals(A) == true
대칭성
A.equals(B) == B.equals(A)
추이성
A.equals(B) && B.equals(C) ⇒ A.equals(C)
일관성
idempotent
A.equals(B) == A.equals(B)
non-null
A.equals(null) == false


### 상속관계 equals를 구현하는 경우 상당히 골치아파짐

ex) Point(int x, int y) 를 상속하는 ColorPoint(int x,int y, Color c)

```java
@Override
public boolean equals(Object o) {
	return (Point)o.x == this.x && (Point)o.y == this.y;
```

이런 경우 
Point(1,2) == ColorPoint(1,2,Yellow)
Point(1,2) == ColorPoint(1,2,Green)
⇒ ColorPoint(1,2,Yellow) == ColorPoint(1,2,Green) (?!)
추이성 바로 깨짐

```java
@Override
public boolean equals(Object o) {
	if(o instanceof ColorPoint){
			return (ColorPoint)o.x == this.x && (ColorPoint)o.y == this.y
							&&(ColorPoint)o.color == this.color;
		return (Point)o.x == this.x && (Point)o.y == this.y;
}
```

이렇게 하면 해결은 됨
다만 Point 하위에 많은 클래스들이 있는경우 + 같은 depth의 클래스를 비교하는 경우의 수가 많아짐
 + 밑의 코드는 StackOverFlow 위험

```java
@Override
public boolean equals(Object o) {
	if(o instanceof ColorPoint){
			return (ColorPoint)o.x == this.x && (ColorPoint)o.y == this.y
							&&(ColorPoint)o.color == this.color;
		return o.equals(this);
}
```


이런식으로 Composition을 구현하는것도 도움

equals를 오버라이딩이 아닌 오버로딩하는 경우 collection 같은 외부에서 쓸 일이 없으니 굳이 쓰지 말자..



```java
public class ColorPoint {
	private final Point point;
	private final Color color;
	public ColorPoint(int x, int y, Color color){
		point = new Point(x,y);
		this.color = Objects.requireNonNull(color);
	}
	
	public Point asPoint() { return point; }
	//포인트 뷰 반환
	@Override public boolean equals(Object o){
		if(!(o instanceof ColorPoint))
			return false;
		ColorPoint cp = (ColorPoint) o;
		return cp.point.equals(point) && cp.color.equals(color);
	}
```


구현 팁
this == o 인지 본다 (주소값 레벨) > 같으면 바로 리턴
instanceof로 타입 비교
해당 타입으로 타입캐스팅
값들 중 반드시 비교해야 할 값 비교
primitive type은 ==로 비교
reference type은 equals로 비교
그냥 구글 AutoValue를 써도된다
다만 annotatino을 읽어서 컴파일 타임에 추가적으로 클래스를 생성하는 것(롬복처럼 클래스에 메서드 넣어주는것 아님)