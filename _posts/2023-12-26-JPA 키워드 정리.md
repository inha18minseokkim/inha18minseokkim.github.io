---
title: JPA 키워드 정리
date: 2023-12-26
tags:
  - JPA
  - Spring
category: 기술
---
FK 기준 양방향 join → 객체의 reference id 기준 연관관계


PK를 기준으로 매핑하지 않고 비즈니스에 영향을 받지 않는 자체 id 사용(비식별 관계)

프록시
식별자 기준으로 조회하는 경우 쿼리를 실행하지 않는경우도 있음(이미 메모리에 올라오면)
프록시 사용을 통해 즉시/지연로딩 사용 가능
  - 즉시의 경우 쿼리씀
    - fk가 nullable이면 기본으로 outer join 사용, nullable=false로 not null 보장하면 inner join 사용
  - 지연의 경우 분리 - 객체 그래프 탐색
  - 연관된게 컬렉션의 경우 지연로딩 자동
    - 1:N 관계 즉시 컬렉션 로딩 시 JPA는 outer join 사용
영속성 전이
  - 연관관계 맺은 프록시 각각 entitymanager.persist 호출하지 않고 부모에 CASCADE 옵션 걸어놓으면 연관관계 맺은 프록시 모두 영속가능
  - 영속상태로 만들어서 db 저장 시 연관된 엔티티중 하나라도 영속상태가 아니면 예외발생
  - 부모 엔티티 지울 때 연관관계 있는 자식도 다 삭제하는 옵션 있음. CascadeType.REMOVE 사용 안할 시 자식을 삭제하진 않지만 DB에서 어차피 외래키에러남
Embeddable
  - 산개한 column들을 응집력있게 표현가능(우편코드,시군구,동호수 필드 → 주소 객체로), 테이블이 만들어지는게 아니라 column field로 
  - 값 타입의 값을 수정하는 경우 연관되는 테이블의 엔티티 싹 delete 후 재insert 하므로 한 타입에 연관된 테이블이 많은 경우 성능이슈 발생가능
  - 그리고 공유하면 문제생길수도 + SETTER 없는것 권장
Mybatis + JPA 사용 시 영속성 컨텍스트를 적절한 시점에 flush 해줘야함
  - Mybatis 커넥션은 하이버네이트가 관리하지 않기 때문에 무결성 훼손 가능
  - Spring 에서 제공하는 커넥션 사용 권장 - Mybatis 사용시 알아서 플러시해줌
JPQL 엔티티 조회 시 이미 영속성 컨텍스트에 해당 엔티티 존재 → 영속성 컨텍스트 엔티티를 반환
  - JPQL 등 SQL 실행 시 EntityManager 자동으로 flush
  - flushMode를 AUTO → COMMIT으로 바꾸면 데이터 정합성 문제 생길 수 있지만 비즈니스 내부에서 flush를 여러 번 호출하는 경우 최적화 수단으로 바꿀 수 있음
도메인 모델 패턴
  - 엔티티가 비즈니스 로직을 가지고 객체지향 특성 적극 활용
트랜잭션 스크립트 패턴
  - 서비스 계층에서 대부분 비즈니스 로직 처리
변경감지 기능은 영속성 컨텍스트 내에서만 유효
  - 엔티티를 영속성 컨텍스트에서 제외하고 지연로딩 사용하면 예외 발생
모든 연관엔티티 조회 시 N+1문제 발생 
  - 엔티티 fetchType.EAGER로 해놓고 em.find를 호출(엔티티 호출)은 괜찮지만 JPQL 호출 시 select 남발가능
  - Hibernate의 @BatchSize 사용 시 어느정도 해결가능
  - fetchJoin 시 해결 가능. 일대 다 조인을 하였으므로 중복을 피하기 위해 distinct 걸어
@Transactional 사용 시 this 호출 문제로 인해 proxy 적용 안될 수 있음
  - 서비스를 분리하여 Facade를 두던지 해야됨
  - aspectj로 바이트코드 조작하는 프록시 기법의 경우 문제없음
OSIV - 뷰까지도 영속성 컨텍스트 사용할 수 있다
  - MCI 사용하는 우리는 쓸수있나 모르겠다
영속성 컨텍스트에 컬랙션 영속화할 때 Hibernate는 Persistent*로 컬랙션을 한번 감싼다
@Converter, AttributeConverter<T,R>를 entity 필드에 사용하면 sql에 저장할 때 값 변환 가능
  - AttributeConverter를 구현한 클래스에 @Converter(autoApply=true)를 지정하면 해당 타입은 모두 변환되어서 저장됨
스칼라 타입으로 jpql 출력 시 영속성 컨텍스트에서 안다룸
  - 그러므로 메모리 절약가능
읽기전용 쿼리 힌트 있음
  - org.hibernate.readonly 사용시 스냅샷 보관 없이 별도 조회
  - @Transactional 에서 readOnly=true 셋팅해도 비슷
엔티티에 리스너 달 수 있음
  - PostLoad,PrePersist,PreUpdate,PreRemove,PostPersist,PostUpdate,PostRemove
  - 엔티티 직접 등록, 별도 리스너 등록, 기본 리스너 사용 방식 모두 가능
예외 변환 → PersistenceExceptionTranslationPostProcessor를 빈등록
  - data 계층 예외를 스프링 예외로 변환하여 예외가 물고 물고 의존되는것을 방지
  - JPA 예외 → Spring 예외로 변환하는 AOP 지원하는 빈
예외 → 롤백 시 DB는 롤백이 되지만 영속성은 롤백안된다
  - 물론 자동으로 em.clear()를 호출하지만 OSIV같은거 써서 트랜잭션 범위가 더 넓어지면 클리어 알아서 잘 하자
Entity 다형성(프록시 방계 문제
  - 프록시로 인해 Entity 다형성 활용 못할 수 있음
  - JPQL로 직접 조회시 하위클래스를 직접 구현한 타입이 반환됨 - but 다형성 활용 못함
  - unProxy 기술 사용 - 엔티티 프록시가 더이상 아니어서 영속성 컨텍스트의 엔티티와 비교시 다르다고 뜸
