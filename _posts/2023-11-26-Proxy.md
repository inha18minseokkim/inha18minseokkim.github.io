---
title: Proxy
date: 2023-11-26
tags:
  - Java
  - Spring
  - 이슈정리
category:
  - 기술
---
정리한 이유) 회사에서 BXM 프레임워크 오류난것 로그트레이싱을 하다가 이상한쪽으로 빠져서 보니 프록시라는 기술이 있더라.. 김영한 아저씨 강의를 들어봄


# 프록시 패턴/데코레이터 패턴

중간에 처리 서비스를 호출할 때 Impl을 직접 호출하는것이 아니라 중간 계층을 둠(Proxy 객체)

![이미지](/assets/images/Pasted%20image%2020260223181907.png)

해당 프록시 객체에서 다음과 같은 일을 할 수 있음
접근 제어
엄마에게 라면을 사달라고 부탁 했는데, 엄마는 그 라면은 이미 집에 있다고 할 수도 있다. 그러면 기대한 것보다 더 빨리 라면을 먹을 수 있다. (접근 제어, 캐싱,Lazy access)
해당 클래스의 메서드에 공통 로직 붙임(메서드 call 전에 로그하는걸 넣는다던지..트랜잭션을 잠근다던지..)
아버지께 자동차 주유를 부탁했는데, 아버지가 주유 뿐만 아니라 세차까지 하고 왔다. 클라이언트가 기대한것 외에 세차라는 부가 기능까지 얻게 되었다. (부가 기능 추가)

소스코드 예제는 인터넷에 많아서 생략. 
핵심: 타겟 클래스의 메서드들이 공통으로 처리했으면 하는 메서드들의 원본 소스코드를 건들지 않고 그 하위의 실행단(클라이언트 코드)만 프록시를 호출하는식으로 바꿔서 실행하는것
문제는 클라이언트코드가 더러워진다(기존 비즈니스 코드 수정은 하지 않지만 하위 코드들은 수정해야함) 
그리고 각 클래스에 대응하는 프록시 코드를 추가해야되므로 개발자 입장에서 상당히 귀찮음
그리고 내가 구현했던 것들은 단순 BXM 빈 만드는거라.. 다른 방법이 있을듯함

# 동적프록시

JDK에서 제공하는 프록시
생성될 때 런타임으로 구현(그냥 패턴으로 구현하는 경우 함수를 호출하는 부분 → object.method(args) 이 부분이 하드코딩되어있다고 생각하면 동적프록시는 이 부분마저도 **추상화**시켜버림)

```java
package java.lang.reflect;
  public interface InvocationHandler {
       public Object invoke(Object proxy, Method method, Object[] args)
          throws Throwable;
}
```

해당 인터페이스를 구현하면 된다
Object proxy : 프록시 자신
Method method : 호출한 메서드
Object[] args : 메서드를 호출할 때 전달한 인수
InvocationHandler를 구현한 함수**(target 객체를 주입받아야하는게 마음에 안들긴함)**

```java
@Slf4j
public class TimeInvocationHandler implements InvocationHandler {
    private final Object target;

    public TimeInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        log.info("TimeProxy 실행");
        long startTime = System.currentTimeMillis();
        Object result = method.invoke(target, args);
        long endTime = System.currentTimeMillis();
        log.info("TimeProxy 종료, resultTime = {}",endTime-startTime);
        return result;
    }
}
```

실제 client side의 함수

```java
AInterface target = new AImpl();
TimeInvocationHandler handler = new TimeInvocationHandler(target);
AInterface proxy = (AInterface) Proxy.newProxyInstance(AInterface.class.getClassLoader(),
									 new Class[]{AInterface.class}, handler);
String call = proxy.call();
log.info("targetClass={}",target.getClass());
log.info("proxyClass={}",proxy.getClass());
```

그냥 프록시 패턴을 사용하는것 보다는 코드가 간결해졌음. 하지만 인터페이스 없는 클래스는 사용할 수 없다.

# CGLIB

이걸 보자마자 머리를 탁 쳤다. **바이트코드를 조작**해서 쓰는것. BXM bean 생성 관련해서 오류났을때 로그트레이싱하면 심심찮게 보이던 라이브러리..

구현(org.springframework.cglib.proxy.MethodInterceptor)

```java
@Slf4j
public class TimeMethodInterceptor implements MethodInterceptor {
    private final Object target;

    public TimeMethodInterceptor(Object target) {
        this.target = target;
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        log.info("TimeProxy 실행");
        long startTime = System.currentTimeMillis();
        Object result = methodProxy.invoke(target, args);
        //Object result = method.invoke(target, args);
        long endTime = System.currentTimeMillis();
        log.info("TimeProxy 종료, resultTime = {}",endTime-startTime);
        return result;
    }
}
```

실제 사용하는 클라이언트코드

```java
ConcreteService target = new ConcreteService();//비즈니스 클래스
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(ConcreteService.class);
enhancer.setCallback(new TimeMethodInterceptor(target));
ConcreteService proxy = (ConcreteService) enhancer.create();
log.info("targetClass={}",target.getClass());
log.info("proxyClass={}",proxy.getClass());

proxy.call();
```

Enhancer를 사용, MethodInterceptor를 사용
Enhancer를 사용하여 프록시 생성
setSuperclass에 타입을 명시하여 해당 타입으로 생성하게끔 함
setCallback에 MethodInterceptor 타입을 지정하여 intercept 로직을 실행하도록 함
create를 하여 프록시가 싸고있는 객체 생성. setSuperclass에 타입을 명시해뒀으니 캐스팅 가능

```java
17:10:34.151 [Test worker] INFO hello.proxy.cglib.CglibTest - targetClass=class hello.proxy.common.service.ConcreteService
17:10:34.154 [Test worker] INFO hello.proxy.cglib.CglibTest - proxyClass=class hello.proxy.common.service.ConcreteService$$EnhancerByCGLIB$$25d6b0e3
17:10:34.154 [Test worker] INFO hello.proxy.cglib.code.TimeMethodInterceptor - TimeProxy 실행
17:10:34.162 [Test worker] INFO hello.proxy.common.service.ConcreteService - ConcreteService 호출
17:10:34.162 [Test worker] INFO hello.proxy.cglib.code.TimeMethodInterceptor - TimeProxy 종료, resultTime = 7
```

BXM로그 찍을 때 CGLIB,enhancer 같은 로그가 찍히는거 보면 Application ClassLoader에 위와 비슷한 로직을 박아놓은 것 같음. 회사에서 봤던거랑 비슷함. 출근해서 확인 ㄱㄱ

단점
부모 클래스 생성자 - 기본생성자 필요함
final 클래스는 사용 불가 - 예외 발생
final 메서드 사용불가 - 프록시 로직 동작 안함

# ProxyFactory

org.springframework.aop.framework의 ProxyFactory를 사용하여 JDK Dynamic(인터페이스 있을 때만)과 CGLIB(인터페이스 없어도 가능) 두 가지 프록시 기법을 사용 가능.
InvocationHandler,MethodInterceptor(패키지이름만 같고 CGLIB꺼)를 추상화한 Advice(를 상속하는 MethodInterceptor)를 사용

![이미지](/assets/images/Pasted%20image%2020260223181920.png)

```java
@Slf4j
public class TimeAdvice implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        log.info("TimeProxy 실행");
        long startTime = System.currentTimeMillis();
        //Object result = method.invoke(target, args);
        Object proceed = invocation.proceed();
        long endTime = System.currentTimeMillis();
        log.info("TimeProxy 종료, resultTime = {}",endTime-startTime);
        return proceed;
    }
}
```


```java
void interfaceProxy() {
    ServiceInterface target = new ServiceImpl();
    ProxyFactory proxyFactory = new ProxyFactory(target);
    proxyFactory.addAdvice(new TimeAdvice());
    ServiceInterface proxy = (ServiceInterface)proxyFactory.getProxy();
    log.info("targetClass = {}",target.getClass());
    log.info("proxyClass = {}",proxy.getClass());
    proxy.save();
}
```


[Proxy 이슈]({% post_url 2023-12-05-JDK Dynamic Proxy Casting이슈 %})
