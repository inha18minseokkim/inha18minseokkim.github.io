---
title: 싱글톤 패턴
date: 2023-09-05
tags:
  - 개발
  - Java
---
파이썬에서는 static한 변수를 만들어놓고 생성자 호출 시 해당 변수가 null인경우 생성후 리턴, 아닌경우 해당 객체를 리턴 하는식으로 생성자 제한하여 싱글톤을 구현하였음
자바에서는?

```java
public class Elvis{
/*주석으로 싱글톤 패턴이라고 명시하면 maven javadoc에서 알아서 해주겠지*/
	public static final Elvis INSTANCE = new Elvis();
	private Elvis() {} //생성자 private 제한
}
```

비슷한 방식으로 제한함

## 단점

싱글톤 사용할 때 클라이언트 테스트 하기 어려워짐
- 해당 부분은 정확하지는 않지만 싱글톤으로 나타낸 이유가 결국은 race condition이나 특정 자원을 독점적으로 사용하여 해결하는 문제인 경우 stateless한, 좀더 엄밀히 이야기하자면 idempotent하지 않은 경우 테스트 하는것이 어렵다 이런말인것 같음
- 테스트로 날렸는데, 실제로 db에 접근해서 수정하거나, 네트워크를 타고 가서 외부의 무언가를 건들고 실제 동작에 영향을 주는 경우가 있다고 생각
- 그러므로 상위 엔터페이스를 구현한 형제 Mock객체를 활용하여 테스트를 하는 것이 한 가지 방법(개발 서버,스테이징 서버, 운영 서버 따로 있는 것 처럼)
Reflection을 사용할 때 싱글톤이 깨질 수 있음

```java
try{
	Constructor<Elvis> defaultConstructor = Elvis.class.getDeclaredConstructor();
	defaultConstructor.setAccesible(true);
	Elvis elvis1 = defaultConstructor.newInstance();
	Elvis elvis2 = defaultConstructor.newInstance();
	System.out.println(elvis1 == elvis2);
} catch {
...
```

- 이런식으로 Reflection단위로 접근하는 경우(이런 개발자가 있으면 따로 불러서 코드를 처리하든지 개발자를 처리해야할 듯 하지만) setAccessible 하나에 깨질 수 있음
- 그러므로 생성자를 좀 더 타이트하게 선언해놓을 필요가 있음

```java
private static boolean created;
private Elvis() {
	if(created) { throw new UnsupportedOperationException("생성자 호출 불가");}
	created = true;
}
```

직렬화 역직렬화를 사용하는경우 또 싱글톤이 깨질 수 있음
- 파일에서 읽어와서 instantiate하는 경우 다른 메모리에 각각 할당될 수 있다.

```java
try (ObjectOutput out = new ObjectOutputStream(
						new FileOutputStream("elvis.obj"))){
	out.writeObject(Elvis.INSTANCE);
	} catch(IOException e) {
		..//이런 식으로 out1, out2... 여러 번 출력하면
```

- 역시 개발자를 처리하도록 하든지 아니면 Serializable에서 사용하는 readResolve() 메서드를 오버라이딩 해서 제한하자.

```java
private Object readResolve() {
		return INSTANCE;//역직렬화 하는 경우 그냥 현재 생성된 인스턴스 리턴
}
```


사실 그냥 스프링 IOC 이용하는게 좋을지도…스프링 부트 못쓰는 카드 서버에서는 쓸 수 있을듯하다. 아무튼 원리는 이렇다
