---
title: "IOC"
date: 2023-09-09
tags: [미지정]
---
Inversion Of Control - 뒤집힌 제어권
자기 코드에 대한 제어권을 자신이 가지고 있지 않고 위에서 제어하는 경우
제어권 : 인스턴스 만들거나 어떤 메소드 실행, 필요로 하는 의존성 주입
클래스 메서드 그 자체가 stateless한 경우도 해당됨(설명 정확도 50%)

스프링 IOC 컨테이너
십수년동안 수많은 나보다 머리좋은 개발자들이 검증완료, 개선중
스프링 context 내에서 스코프 쉽게 관리 가능(바깥으로 벗어나면 안되지만..)
Bean관련 라이프사이클 인터페이스 제공
생성하자마자 데이터 초기화, 외부와 연결해서 뭔가 하거나 종료할 때 리소스 반납하거나 해야하는 설정 스프링이 챙겨줌
스프링은 POJO 지향.. 기존에 만든 클래스들 그냥 Configuration(@Configuration 어노테이션이 붙어있는 클래스)에 @Bean으로 등록하거나 그렇게 하면 스프링이 관리 가능. 침투적이지 않음

```java
@Configuration
public class AppConfig {
	@Bean
	public SpellChecker spellChecker(Dictionary dictionary) {
 //스프링이 관리하고 있는 딕셔너리 넘겨주면 스프링이 알아서 함
		return new SpellChecker(dictionary);
	}
	@Bean
	public Dictionary dictionary() {
		return new SpringDictionary();
	}
}
```


```java
public static void main(String[] args) {
	ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
	SpellChecker bean = applicationContext.getBean(SpellChecker.class);
	}//new 말고 이렇게 가져와야 Spring 컨텍스트에서 인식 가능. 별다른 설정 없으면 싱글톤
```


귀찮으므로 우리는 @Component 같은 것을 annotate 해놓고 @ComponentScan 하면 자동으로 등록

```java
@Configuration
@ComponentScan(basePackageClasses = AppConfig.class)
public class AppConfig {

}
```



### 그럼 왜 static을 쓰지 않고 Singleton을 쓰는가

static은 객체를 만들지 않음(이건 그럴 수 있다쳐도) 
오버라이딩, 인터페이스 구현 불가능
컴파일 타임에 싹다 로딩(lazy load 안됨)
그러므로 저장위치는 힙이 아닌 스택
state in static class is nightmare - 동시성 환경에서 race condition 문제


DAO를 static이 아닌 싱글톤으로 구현하는 이유?
[https://okky.kr/questions/583814](https://okky.kr/questions/583814)
요약 : 구현의 편리성 
> [https://stackoverflow.com/questions/519520/difference-between-static-class-and-singleton-pattern](https://stackoverflow.com/questions/519520/difference-between-static-class-and-singleton-pattern)
