---
title: "회의록(야놀자 사례)"
date: 2023-09-04
tags: [미지정]
---

## 서버 아키텍처

- **프론트 서버**: 렌더링 전담. 비즈니스 로직은 백엔드로 위임
- **Web-API 서버 (Mashup)**: 기존 레거시 서버들을 묶어 새로운 서비스에 연결
- **Provider 서버**: 외부 애플리케이션에서 API 호출 시 내부 표준 명세로 변환해주는 서버
  - 외부 애플리케이션 장애 시 어쩔 수 없는 한계는 존재

---

## 관측성 (Observability)

- **Envoy** 도입으로 개발 공수가 크게 늘진 않았고, 대신 분산 추적(tracing)이 가능해짐
- **Grafana**: 애플리케이션 통계·모니터링 용도
- **Kibana**: Slack 연동으로 에러 탐지 용도로 사용 — Slack이 시스템 알림 연동이 쉽고 잘 되어 있음
- **로그 추적**: 헤더에 키를 삽입하는 방식 (Service Mesh 레벨에서 처리)

---

## 데이터 저장 전략

- **Aurora MySQL**: 주문·결제·고객 정보 저장
  - 중요 개인 식별 정보는 별도 Cold DB 사용
  - 저장 자체를 최소화하려 하며, 반드시 필요한 데이터도 동일 DB에 혼재시키지 않음
- **Redis**: 캐시 전략 — 약 1시간 내 만료될 단기 정보 저장
  - 개발자가 TTL을 직접 설정해 DB insert 여부를 관리하던 방식에서 전환
- **Kafka**: 데이터 스트림 기반의 개인화 메시지 발송
  - 비즈니스 로직과 완전히 분리(decoupled)된 구조
  - ex) 결제·발권 완료 시 정해진 포맷으로 적재 → 이벤트 발행 여부는 별도 판단

---

## 기술 선택

- **WebFlux → WebClient + Spring MVC**: 검색 쪽은 Non-blocking이 적합하나, 기술 난이도가 높아 WebClient만 채택하고 MVC 기반으로 유지
- **gRPC**: 현재도 사용 중이나 러닝커브가 있음
  - 한 프로젝트에 기술을 너무 많이 넣으면 표준 수립이 어려워짐
  - 기술 리더 중심으로 팀원 합의를 거쳐 도입 결정

---

## 테스트 규칙

- 컨트롤러 · 서비스 · 매퍼는 각각 1:1 대응 테스트 작성 원칙
- **Mapper**: 비즈니스상 변환 로직이 없더라도 별도 매퍼 계층을 두고 테스트 코드 작성
  - 명세는 언제든 바뀔 수 있으므로, in/out이 같아도 매퍼를 선언해두고 컨트롤러에서 사용
- **디렉터리 구조**: 각 비즈니스 도메인 폴더 내에 `controller` / `service` / `mapper` / `dto` 4개 폴더로 구성
- **REST API**: 글로벌 표준에 맞게 작성
- **DTO**: `class` 대신 `record` 사용 — 자동으로 `private` 필드, 컴파일러 최적화, Lombok 호환

---

## 공통 영역

- `common` 영역에 외부 서버 호출용 WebClient Exchange 구현체 배치

---

[AA]({% post_url 2023-09-05-AA %})
