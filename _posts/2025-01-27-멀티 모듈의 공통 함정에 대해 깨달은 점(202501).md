---
title: "멀티 모듈의 공통 함정에 대해 깨달은 점(202501)"
date: 2025-01-27
tags:
  - 개발
  - 아키텍처
  - Java
category:
  - 기술
---
Spring Gradle 멀티 모듈 구성 시 공통적으로 발생하는 함정과 해결 방법 정리.
[멀티모듈 설계 이야기 with Spring, Gradle | 우아한형제들 기술블로그](https://techblog.woowahan.com/2637/)

작년 7월에 눈물의 저글링쇼를 위해(행내 정책상 1문서 : 1프로젝트이므로 프로젝트 30개를 만듬, 그에 따른 공통 소스코드의 일관성 유지를 위해) 멀티모듈을 도입했다.
당시 위 우아한 선생님의 글을 읽어보고 멀티모듈의 공통의 영역을 정하는 것이 상당히 어려운 일이구나, 라는것을 느낌.
  - 너무 쪼갠다 > 각 서브모듈 관리가 힘들어짐
  - 그렇다고 모두 합친다 > 짬통이 될 가능성이 있다. 그리고 그 짬통을 사용하는 프로젝트가 많아지고, 그 짬통을 수정한다 > 모든 프로젝트에 영향을 받음 
일단 이런 애로사항이 있을 수 있다는것을 생각하고 우선 “레이어 기반”으로 접근해보기로 했다.

```java
- listed-stock-common  # 공통 코드나 단위업무에서 쓰이는 유틸들(java코드로만 이루어짐)
	- listed-stock-jpa   # jpa 관련 entity, converter, envers config 등
	- listed-stock-redis # redis 관련 dto, template, config 등 
	- listed-stock-kafka # kafka 관련 consumer,producer config template 등
```

redis, kafka 처럼 특정 기술 스택을 멀티 모듈로 직접 말아놓는것이 맞냐는 것에는 의문이 있다.
엄밀하게 이렇게 하고 싶긴 하다

```java
- listed-stock-common  # 공통 코드나 단위업무에서 쓰이는 유틸들(java코드로만 이루어짐)
	- listed-stock-data  # data 관련 dto, config 등등
		- listed-stock-jpa # 기본스펙 hibernate 관련 config, repository
		- listed-stock-r2dbc # r2dbc 관련 config 등
	- listed-stock-cache # 캐싱에 사용할 dto, cacheconfig 등등
		- listed-stock-redis
		- listed-stock-caffeine
	- listed-stock-message-queue 
		- listed-stock-kafka
```

추상화된 공통 하나 짜놓고, 세부 구현(기술스택에 의존하는 config, 모듈 등)은 하위 모듈로 빼는식으로 레이어를 지키면 좀 더 멋드러질 것 같지만, 
1. 저걸 다 구현해줘야함
2. 내 업무에서 기술스택이 저정도로 다양하게 쓰일까
라는 생각이 들어서 간단하게 위처럼 구현 해놓고 나중에 세부 기술 스택을 빼는 형태로 구현하기로 했다.
다만 그렇게 하기 위해서는, 현재 listed-stock-jpa 레이어를 최대한 얇게(?) 가져가야 한다고 생각한다.
가령, 지금 절대 내가 jpa 모듈을 대충 짜놓고 r2dbc를 붙이려고 하다가 꼬여서 옛날에 봤던 문서들을 보고 다시 무언가를 깨달아서 글을 쓰는건 아니고(…)
ASIS

```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    implementation project(path: ':listed-stock-common')
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.17.2'
}
bootJar.enabled = false

task prepareKotlinBuildScriptModel {}

tasks.named('bootBuildImage') {
    enabled= false
}
```

TOBE

```groovy
dependencies {
    implementation 'jakarta.persistence:jakarta.persistence-api:3.2.0'
    implementation 'org.springframework.data:spring-data-jpa'
    implementation 'org.springframework.data:spring-data-relational'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    implementation project(path: ':listed-stock-common')
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.17.2'
}
bootJar.enabled = false

task prepareKotlinBuildScriptModel {}

tasks.named('bootBuildImage') {
    enabled= false
}
```


역시 부딪혀보면서 느끼는게 직빵인게, 새로운 뭔가를 하면 과거에 했던것들이 얼마나 생각없이 했는 것들인지 알 수 있다. 상위 모듈, 즉 spring boot starter jpa 모듈을 상위 모듈이 의존한다면 모듈이 상당히 두꺼워져서 그걸 상속받는 말단 프로젝트들의 확장성이 상당히 떨어진다.(이번 기회에 spring boot starter가 뭔지 어느정도 알았다)
  - 그리고 스프링 부트를 사용함으로써 자동으로 뭔가가 다 만들어지기 때문에 불필요한 설정이 동작할 확률이 높음.
모듈에서는 orm을 어떻게 쓸건지, 테이블매핑을 어떻게 할건지(엔티티 명세) 정도의 “가이드라인” 만 선언해놓고 세부적인 구현은 하위 모듈 내지 말단 어플리케이션에서 하는게 멀티 모듈의 공통 지옥에서 빠져나가는 한 가지 방법이라는 것을 깨달았다.
그러므로 딱 이 케이스에 한해서만 국소적으로 봤을 때 spring-boot-starter-jpa는 공통 모듈 레벨이 아니라 공통 모듈을 사용하는 listed-stock-service, 즉 MVC 를 구현하는 어플리케이션에서 사용하는것이 적절하다고 본다. 
  - ex) 

```java
@Service
@Slf4j
@Transactional(value = "transactionManager") //이런거, 어떤 transactionManager를 쓸지..
@RequiredArgsConstructor
@Primary
public class ListedStockServiceBlockingImpl implements ListedStockService {
```


```java
@SpringBootApplication
@ComponentScan(basePackages = {
        "com.kbank.convenience.stock.listed.stock.service"
        ,"com.kbank.convenience.stock"
})
@EnableJpaRepositories(basePackages = "com.kbank.convenience.stock.jpa.*")
@EntityScan(basePackages = "com.kbank.convenience.stock.*")
@EnableR2dbcRepositories(basePackages = "com.kbank.convenience.stock.listed.stock.*")
@Import(DataSourceAutoConfiguration.class) //이런식으로 빈, 엔티티, 레포 선언해놓은 것을 어떤식으로 주입하냐는건 말단 부트 어플리케이션에서 확정짓도록 하자.
public class ListedStockServiceApplication {
```

  - 멀티 모듈에서는 엔티티 선언, 매핑을 할 때 사용하는 최소한의 라이브러리(여기서는 spring-data-jpa, jakarta.persistence 정도)만 있으면 된다. 부트를 사용하면 멀티모듈에서 너무 많은 일을 해버린다.


### 좀 더 생각해봐야 할 것

아무튼 그래서 jpa모듈(장기적으로는 data 모듈)을 주입받아 jpa와 r2dbc를 같이 쓴다고 생각해보자. 공통으로 선언해놓은 엔티티가 다음과 같아진다.

```java
@Builder
@Entity
@AllArgsConstructor
@NoArgsConstructor
@Table(name="TB_STK_LI_STCK_DAILY_INFO_M"
)
@jakarta.persistence.Table(name="TB_STK_LI_STCK_DAILY_INFO_M")
@Getter
@Setter
@IdClass(ListedStockPriceId.class)
public class ListedStockPrice extends TimeStamp implements Serializable {

    @Column("base_dttm")
    @jakarta.persistence.Column(name="base_dttm")
    @Id
    private LocalDate baseDate; //기준일자
    @Column("itms_cd_nbr")
    @jakarta.persistence.Column(name="itms_cd_nbr")
    @Id
    private String itemCodeNumber; //종목코드번호
    @Column("stpr_amt")
    @jakarta.persistence.Column(name="stpr_amt")
    private Long openPrice;//시가금액
```

r2dbc는 orm이 아니기 때문에(jdbc에 가까움) 어노테이션이 다름. 
그리고 onetomany manytoone 이런 것도 못쓰기 때문에 엔티티랑 레포지터리와 같은 infrastructure를 아예 다른 스택으로 선언해서 쓰는게 맞는 것 같다. 
  - 해당 infra를 선언해서 쓰는 것은 domain.service의 impl 구현할 때 사용하는것이 적절해보임
![[Pasted image 20260301003805.png]]
이런식으로, 하지만 블로킹 기반 서비스와 논블로킹 기반 서비스가 같은 인터페이스를 구현하는것은 현실적으로는 힘들어 보임. 앞으로 어떤 업무가 올 지는 모르겠지만 이런 논점들을 정리해놓기로 함.
