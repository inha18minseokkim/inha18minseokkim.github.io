---
title: Redis 싱글스레드 + Multiplexing - 싱글 스레드로 동시 처리 가능한 이유?
date: 2025-01-10
tags:
  - Redis
  - 백엔드
  - 아키텍처
category: 기술
---

Redis는 싱글스레드로 동작한다.

싱글스레드로 동작하기 때문에 빠른 접근 + Race condition 가능성이 없다.

그럼 다중 요청은 어떻게 처리할까?
![이미지](/assets/images/Pasted%20image%2020260220120307.png)


## 이벤트 루프 기반의 논블로킹 I/O

이벤트 루프 기반 논블로킹 방식으로 다중 요청을 병렬처럼 처리한다.

1. 클라이언트 소켓에서 요청을 이벤트 큐에 등록
2. 싱글 스레드 메인 루프가 이 요청들을 하나씩 빠르게 처리
3. 각 명령어는 매우 빠르게 완료되므로 수천~수만 RPS도 처리 가능

Redis의 각 명령어는 O(1) 또는 O(n)으로 매우 빠르게 끝나기 때문에, 싱글 스레드임에도 다음 요청이 대기하는 시간이 매우 짧다. Multiplexing(다중화)으로 여러 클라이언트의 소켓을 하나의 스레드가 감시하면서 처리하는 구조다.

## I/O 멀티스레딩

Redis 6.0부터 명령어 파싱, 응답 송신 등의 **네트워크 I/O를 멀티 스레드로 처리**할 수 있게 됐다.

단, 실제 명령어 실행(데이터 읽기/쓰기)은 여전히 싱글 스레드다. I/O 처리만 병렬화한 것이기 때문에 Race condition 없이 원자적인 명령어 실행 보장은 유지된다.

---

**핵심 정리**

| 구분 | 스레딩 방식 |
|---|---|
| 명령어 실행 | 싱글 스레드 |
| 네트워크 I/O (Redis 6.0+) | 멀티 스레드 가능 |
| 다중 클라이언트 처리 | 이벤트 루프 + Multiplexing |


만약 요청이 3개라면

Client A -> SET key1 value1 Client B -> GET key2 Client C -> INCR counter

하나씩 큐에 순서대로 넣고 빠르게 처리할 예정

### ❗ 왜 굳이 싱글스레드로 유지할까?

- 동시성 이슈 없음 (락이나 뮤텍스 필요 없음)
    
- 코드 간단 + 빠름
    
- 대부분의 명령어는 수 μs 단위로 처리 가능
    
    그러니깐 마이크로초 단위로 처리가 되지않으면 위험하다(keys * 같은 명령어를 쓰지 말라는 이유)
    

### 근데 스레드 여러개이기도 하잖아?

```python
ps -eLf | grep "redis"
asdf 31860  2920 31860 10    3 22:58 pts/0    00:00:05 src/redis-server *:6379
asdf 31860  2920 31861  0    3 22:58 pts/0    00:00:00 src/redis-server *:6379
adsf 31860  2920 31862  0    3 22:58 pts/0    00:00:00 src/redis-server *:6379
```

실제로 스레드가 여러 개 일수도 있다.

|스레드 종류|설명|
|---|---|
|**I/O 스레드 (6.0+부터)**|네트워크 요청 수신/응답 처리의 일부를 멀티스레드로 처리|
|**AOF 백그라운드 쓰기**|AOF(Append Only File)를 디스크에 저장할 때 백그라운드 스레드 사용|
|**RDB 저장**|`BGSAVE` 등 RDB 저장 시 별도 프로세스 (fork), 일부 스레드 사용 가능|
|**lazy free**|DEL 등에서 큰 데이터를 삭제할 때 별도 스레드에서 메모리 해제|
|**BIO threads**|백그라운드 입출력 작업 (`BIO_CLOSE_FILE`, `BIO_AOF_FSYNC` 등) 처리|

결국 명령어 처리 자체는 여전히 싱글스레드다.

다만 네트워크나 디스크 IO를 처리하기 위해서는 백그라운드에 별도에 스레드가 있는 구조.

우리가 코루틴 스코프를 사용할 때 [Dispatcher.IO](http://Dispatcher.IO) 스레드가 별도로 있는것과 비슷한듯 함.

### 클러스터링 + 샤딩을 하는 경우에는

- **여러 개의 Redis 노드(= 인스턴스)** 가 존재
- 각 노드는 **자기 shard에 해당하는 key 공간만 처리**
- 클라이언트는 키에 따라 **어느 Redis 노드로 보낼지 미리 결정**
- 각 노드는 여전히 **싱글 스레드로 명령어 처리**, 하지만 **전체적으로는 병렬**

즉 해시함수 + 모듈러 조합을 사용하던가 해서 N개의 다른 레디스 노드 안에 N개의 스레드가 병렬적으로 접근하는식으로 구성 가능.

즉 노드 간에 키 충돌이 없기 때문에 race condition 발생하지 않음.

+) redis 7.2 버전부터는 레디스 라이센스 변경 정책으로 인해 더 이상 무료가 아님(정확하게 쓰는건 무료인데 상업용으로 리테일 하는 경우 논란의 여지가 있어서 사실상 유료) . 7.2 포크 버전 Valkey가 있음 이거 쓰셔도 됩니다.