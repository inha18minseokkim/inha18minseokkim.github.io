---
title: KEDA Job(20241021)
date: 2024-10-21
tags:
  - MSA
  - KEDA
  - job
  - argo
  - EDA
category: 기술
---
[KEDA | Scaling Jobs](https://keda.sh/docs/2.14/concepts/scaling-jobs/)

# 하고싶은 것

데이터를 갖고와서 → 대충 정제한 다음 → 토픽에다가 Pub
→ 토픽에 대충 Lag가 쌓이고 있으면
→ KafkaItemReader가 돌면서 Lag가 0이 될 때 까지 Sub 하는 event driven 트리거를 구성하고 싶음

argo event 같은 경우는 kafka topic을 컨슈머로 빨아가기 때문에 이 케이스가 아닌 것 같고, KEDA에서는 LAG가 쌓이는 경우 트리거를 발생시키기 때문에 이 경우에는 KEDA가 적합하다고 할 수 있겠다.
  - 즉 argo-event의 eventsource는 토픽의 레코드 자체가 이벤트 데이터고, KEDA에서 카프카 토픽은 LAG 발생 여부가 이벤트임

현재 행 내에서 Keda를 활용한 ScaledObject를 사용하고 있는데 이건 Deployment 용이라 적합하진 않은 것 같고, 찾아보니 ScaledJob이라는게 있어서 이걸 활용
  - Deployment를 사용한 KEDA의 경우 consumer LAG가 0이 되면(threshold 밑으로 내려가면) 버튼이 눌려서 파드에 SIGTERM을 보내고 파드가 내려가는데, Job을 사용한 KEDA는 현재 떠있는 잡의 수만으로 판단하기 때문에 더 적합한것같음


아래 예시 : ListedStockPrice(물론 네이밍이 국제표준은 아니지만 그냥 연습용이라 생각)라는 토픽의 컨슈머그룹(편의상 토픽이름과 같음)에 LAG가 1이라도 쌓이면 → 스프링 어플리케이션 이미지가 실행되는데, 안의 ListedStockPrice(토픽 이름과 컨슈머그룹 이름과 스프링 빈 이름이 같음) 라는 빈이 실행됨. 이 빈은 Spring Batch KafkaItemReader를 실행함.

```java
apiVersion: keda.sh/v1alpha1
kind: ScaledJob
metadata:
  name: listed-stock-sub-job
  labels:
    my-label: listed-stock-sub-job           # Optional. ScaledJob labels are applied to child Jobs
  annotations:
#    autoscaling.keda.sh/paused: true        # Optional. Use to pause autoscaling of Jobs
    my-annotation: listed-stock-sub-job      # Optional. ScaledJob annotations are applied to child Jobs
spec:
  jobTargetRef:
    parallelism: 1                            # [max number of desired pods](https://kubernetes.io/docs/concepts/workloads/controllers/job/#controlling-parallelism)
    completions: 1                            # [desired number of successfully finished pods](https://kubernetes.io/docs/concepts/workloads/controllers/job/#controlling-parallelism)
    activeDeadlineSeconds: 600                #  Specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it; value must be positive integer
    backoffLimit: 6                           # Specifies the number of retries before marking this job failed. Defaults to 6
    template:
      spec:
        containers:
          - name: listed-stock-sub-job
            image: muyaho/listed-stock-sub-job:latest
            env:
              - name: JOB_NAME
                value: "ListedStockPrice"
  pollingInterval: 30                         # Optional. Default: 30 seconds
  successfulJobsHistoryLimit: 5               # Optional. Default: 100. How many completed jobs should be kept.
  failedJobsHistoryLimit: 5                   # Optional. Default: 100. How many failed jobs should be kept.
#  envSourceContainerName: {container-name}    # Optional. Default: .spec.JobTargetRef.template.spec.containers[0]
  minReplicaCount: 0                          # 0, LAG 없으면 잡 띄우지마
  maxReplicaCount: 5                          # 1, LAG 있으면 잡 띄워 하나만 해도될듯
#  rolloutStrategy: gradual                    # Deprecated: Use rollout.strategy instead (see below).
  rollout:
    strategy: gradual                         # Optional. Default: default. Which Rollout Strategy KEDA will use.
    propagationPolicy: foreground             # Optional. Default: background. Kubernetes propagation policy for cleaning up existing jobs during rollout.
  scalingStrategy:
#    strategy: "custom"                        # Optional. Default: default. Which Scaling Strategy to use. #이것도 0 1따린데 안씀
#    customScalingQueueLengthDeduction: 1      # Optional. A parameter to optimize custom ScalingStrategy.  #이것도 0 1 따리는 안ㄴ쓰는게 좋음
#    customScalingRunningJobPercentage: "0.5"  # Optional. A parameter to optimize custom ScalingStrategy. #min0 max1로 지정하는데 이거 소수점으로 떨구면 파드 안뜸
    pendingPodConditions:                     # Optional. A parameter to calculate pending job count per the specified pod conditions
      - "Ready"
      - "PodScheduled"
      - "AnyOtherCustomPodCondition"
    multipleScalersCalculation : "max" # Optional. Default: max. Specifies how to calculate the target metrics when multiple scalers are defined.
  triggers:
    - metadata:
        bootstrapServers: '카프카아이피넣어주세요:29092'
        consumerGroup: ListedStockPrice
        lagThreshold: '1'
        offsetResetPolicy: latest
        topic: ListedStockPrice
      type: kafka
```

문제점: 토픽이 N개라 이 파일을 N번 만들어줘야하는데,
뭔가 KEDA 트리거에 메타데이터, 하다못해 발동된 트리거 내용이라도 넣을 수 있을것이라고 생각하고 열심히 찾아봤는데 아직 없다.

근데 올 초에 나랑 비슷한 생각을 한 사람이 있어서 봤는데 이사람은 이제 쿠버네티스에 관심이 없어서 closed 되었다(stale).. 내가 물어보는중

만약에 이게 안된다고 하면 분기 없이 무조건 이미지를 실행시키고 스프링 배치 빈을 N개 띄워버리자. 어차피 LAG 생긴거 다 적재할거고 떴는데 LAG 0이면 바로 닫힐테니깐 상관없지않을까?

![이미지](/assets/images/Pasted%20image%2020260225093156.png)

ㅇㅇ LAG 없으면 그냥 끝남 있는것만 물고있음 뜨자마자 꺼진것 확인 됨

일단 질문은 던져놨고 


```yaml
home@homeui-Macmini ~ % kafka-consumer-groups  --bootstrap-server localhost:29092 --group ListedStockPrice --describe

Consumer group 'ListedStockPrice' has no active members.

GROUP            TOPIC            PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID     HOST            CLIENT-ID
ListedStockPrice ListedStockPrice 0          930710          969009          38299           -               -               -%
home@homeui-Macmini ~ % kafka-consumer-groups  --bootstrap-server localhost:29092 --group ListedStockPrice --describe

Consumer group 'ListedStockPrice' has no active members.

GROUP            TOPIC            PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID     HOST            CLIENT-ID
ListedStockPrice ListedStockPrice 0          947809          969009          21200           -               -               -%
home@homeui-Macmini ~ % client_loop: send disconnect: Connection reset
```

잘 되는듯

![이미지](/assets/images/Pasted%20image%2020260225093204.png)

argo-workflow에서 api 호출 잡 실행 → LAG 생김 → KEDA가 sub batch 실행
잘된다

![이미지](/assets/images/Pasted%20image%2020260225093211.png)
데이터 적재도 정상적으로 되고있다.

![이미지](/assets/images/Pasted%20image%2020260225093216.png)

보면 배치가 뜨면서 LAG 소모 → 0 되면서 배치 어플리케이션 종료 → 계속 쌓임 → 또 뜸 이런식으로 잡이 내려갔다 떴다 하면서 소모해줌
Failed는 스프링 앱 종료하면서 0을 리턴해주는 로직 넣어야하는데 까먹고 안넣음.
기존에 ScaledObject + @Listener 데몬형식의 경우 Deployment 형태다 보니깐 SIGTERM을 시켜서 부자연스럽고, Deployment다 보니 헬스체크 같은것도 막 하다보니 무거운 느낌이었는데 잡 형태로 띄우니 직관적이고 자연스러워 보이는듯.
