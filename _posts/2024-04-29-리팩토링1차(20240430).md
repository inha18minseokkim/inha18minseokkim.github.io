---
title: 리팩토링1차(20240430)
date: 2024-04-29
tags:
  - 케이뱅크
  - 주식서비스
  - 개발
  - 아키텍처
category: 실무경험
---

## V1(이행 시)

![이미지](/assets/images/Pasted%20image%2020260226120005.png)

첫번째 버전(JPA 사용 + QueryDSL 사용)
Table Driven + Redis 캐싱(쿼리 결과에 대한 정적 데이터 캐싱)
흐름 예시
stockDetail: 컨트롤러 호출
  1. getMember: cust_id 없으면 Member 엔티티 생성
    1. memberRepository.findbyId
    2. memberRepository.save
  2. latestBaseDateTime: 가장 최근 기준일자 가져옴(주식 가격 조회 위함)
    1. getLatestBaseDateTime
      - →DAO 사용  (QueryDSL)
  3. getStockDailyInfo: 코어 서비스 호출
    1. getIpoStatus: 종목코드번호에 해당하는 종목의 Ipo정보호출
      - →getIpoScheduleDate DAO ⇒ Mybatis 사용
    2. insertInquireHistory: 검색유입이면 검색이력 쌓음
      - →StockInquireHistoryRepository 사용(JpaRepository)
    3. getMemberInterestStockYn: 사용자가 해당종목 관심있으면 하트 그려주는 Y 내보냄
      - →MemberReader DAO 사용(QueryDSL)
    4. getUnListedStockBaseInfo : 해당 종목의 상태(사용여부 가져옴)
      - →StockDetailReader DAO 사용(QueryDSL)
    5. getUnListedStockDailyInfo: 오늘 주식의 상태 가져옴(시총,URL,종목명 등)
      - →StockDetailReader DAO 사용(QueryDSL)
    6. getStockPriceHistories: 최대 90일치 해당 종목의 가격이력 가져옴
      - →StockDetailReader DAO 사용(QueryDSL)

장점 : 
  - 테이블 기준으로 빠른 쿼리 작성(이행계획, 인프라변경 등 다 해서 넉넉하게 3주면 개발 완료,실제 개발은 5일 내)
  - 직접 쿼리 제어가능
단점 :
  1. 복잡함
  2. 과도한 서비스간 상호 호출 때문에 depth가 깊어지고 기준 모호
  3. 2번을 방지하기 위해 Controller에서 비즈니스 로직 호출 후 조립
    1. 서비스와 컨트롤러가 나눠서 조립함(골고루 짬통 서비스)


## V2(고도화 및 1차 리팩토링)

![이미지](/assets/images/Pasted%20image%2020260226120012.png)
두 번째 버전(GO 이후 2주 뒤, Domain 로직 추가, Redis Cache → Persistent Cache)
Domain 일부 추가 + 시계열 데이터 조회는 QueryDSL 사용
선과 노드가 많이 줄어듬
흐름 예시)
stockDetail:컨트롤러 호출
  1. getStockDetailInfo: 
    1. insertInquireHistory
    2. getStockPriceHistories
    3. getStockDailyInfos
    4. getUnListedStockDailyInfos
    5. getLatestBaseDateTime
      - →getLatestBaseDateTime DAO 사용(QueryDSL)
    6. member.isInterest → 사용자가 해당 종목 하트 눌렀는지
    7. unListedStock.getCurrentInterestMembers → 해당 종목을 몇명이 관심누른지


장점:
  - 공통 로직들 Domain Entity로 넣어서 코드 간결
    - DAO에 있는 로직들 공통 도메인 로직으로 처리 가능
  - 비즈니스 로직 Depth 정리 완료(거의 대부분 많아야 2 depth)
  - 어떤 서비스가 짬통 서비스인지 정확하게 알 수 있음
단점:
  - 설계
  - JPA 로직을 잘못 타면 퍼포먼스 문제 됨
    - 그래서 90일자 조회하는 부분은 @ManyToOne 사용하지 않음
  - JPA로 도메인 매핑을 한 이상 Mybatis를 사용할 때 제약이 어느정도 있음
    - 조회의 경우에는 문제 없을듯
    - insert update delete 시 영속성 컨텍스트와의 싱크 문제
    - 특히 DELETE → Foreign Constraint를 걸어놓지 않았기 때문에(테스트의 용이를 위하여 FK 대신 Index를 걸어놓음) 잘못 Delete 하는 경우 문제 생길 수 있다.
      - 이건 앞으로 같이 협업하는 사람이 누구인지에 따라 달라질듯.
