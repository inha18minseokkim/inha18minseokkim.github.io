---
title: "단일 이미지 빌드 환경에서 멀티모듈 빌드(뻘)"
date: 2025-02-13
tags: [미지정]
category:
  - 기타
---

만약 멀티모듈을 현재 케이뱅크 파이프라인에서 수행한다면, gitlab ci가 정해져있기 때문에 dockerfile을 여러 개 실행할 수 없다.
물론 나중에는 구성해주겠지만.. 지금으로서는 쉽지않으므로 임기응변을 생각해보자.

# 1. gradle 서브모듈 직접 호출


```kotlin
# Gradle 공식 이미지 사용 (빌드 단계)
FROM gradle:8-jdk17 AS builder

# 작업 디렉토리 설정
WORKDIR /app

# Gradle 빌드 파일 및 소스 코드 복사
COPY . .

RUN chmod +X ./gradlew
RUN chmod 755 ./gradlew

# Gradle 캐시 최적화 (선택 사항)
RUN ./gradlew build --no-daemon -x test

# 최종 실행 이미지
FROM eclipse-temurin:17-jdk AS runtime

WORKDIR /app

# 프로젝트 전체 복사 (실행 시 Gradle 사용 가능)
COPY --from=builder /app .

# 실행할 모듈을 환경 변수로 받음 (기본값: service)
ENV TARGET_MODULE=service

RUN ./gradlew bootJar --no-daemon -x test

# 컨테이너 실행 시 지정한 모듈을 bootRun
CMD ["sh", "-c", "./gradlew :$TARGET_MODULE:bootRun"]
```


이렇게도 구성해볼 수 있지만..
좋은 점은 gradle 모듈단위를 그대로 쓸 수 있다(간편)
단점은 java 가 아닌 gradle에 디펜던시를 가진다(느림)

```kotlin
minseokkim@minseokkim-Macmini8-1:~/Documents/listed-stock$ kubectl logs -f listed-stock-service-temp-bf7c9f7dc-5xsjc
Starting a Gradle Daemon (subsequent builds will be faster)
> Task :common:compileJava UP-TO-DATE
> Task :common:processResources NO-SOURCE
> Task :common:classes UP-TO-DATE
> Task :common:jar UP-TO-DATE
> Task :data:compileJava UP-TO-DATE
> Task :data:processResources UP-TO-DATE
> Task :data:classes UP-TO-DATE
> Task :data:jar UP-TO-DATE
> Task :jpa:compileJava UP-TO-DATE
> Task :jpa:processResources UP-TO-DATE
> Task :jpa:classes UP-TO-DATE
> Task :jpa:jar UP-TO-DATE
> Task :redis:compileJava UP-TO-DATE
> Task :redis:processResources UP-TO-DATE
> Task :redis:classes UP-TO-DATE
> Task :redis:jar UP-TO-DATE
> Task :service:compileJava UP-TO-DATE
> Task :service:processResources UP-TO-DATE
> Task :service:classes UP-TO-DATE
> Task :service:resolveMainClassName UP-TO-DATE

> Task :service:bootRun

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.2)
```

이런식으로 gradle을 돌리는 것이라 느리다. was의 경우는 상관없겠지만 spring batch 같은 작업을 돌릴때는 깔끔하지 않다.


# 2. jar 복사 후 호출


```yaml
# Base image
FROM gradle:8-jdk17 AS builder

# 작업 디렉토리 설정
WORKDIR /app

# Gradle 빌드 파일 및 소스 코드 복사
COPY . .

RUN chmod +X ./gradlew
RUN chmod 755 ./gradlew

# 빌드 시 모든 모듈의 JAR 생성
RUN ./gradlew bootJar -x test

# 최종 실행 이미지
FROM eclipse-temurin:17-jdk AS runtime

WORKDIR /app

# JAR 파일 복사
COPY --from=builder /app/service/build/libs/service-*.jar service.jar
COPY --from=builder /app/job/build/libs/job-*.jar job.jar
COPY --from=builder /app/batch/build/libs/batch-*.jar batch.jar

# 실행 시 선택한 모듈의 JAR 실행
CMD ["sh", "-c", "java -jar ${TARGET_MODULE}.jar"]
```

멀티 스테이지를 최대한 활용하여 builder 이미지(gradle이미지 사용)에서 jar파일을 만들어놓고 실제 run 레이어에서는 jdk 이미지로 jar 파일을 복사하여 java jar 실행

```yaml
#job-name을 받아서 step 이름이랑 안에서 도커 이미지 파라미터 물고 실행할 수 있게끔 만듬
apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: listed-stock-symbol-pub-job-
  annotations:
    job-name: "ListedStockSymbolPubJob"
spec:
  entrypoint: main
  templates:
    - name: main
      steps:
        - - name: ListedStockSymbolPubJob
            template: workflow-one
    - name: workflow-one
      container:
        image: muyaho/listed-stock:latest
        command: [ "/bin/sh", "-c" ]
        args:
          - "echo 'Starting Job: ${JOB_NAME}' && ls -al && java -jar ${TARGET_MODULE}.jar"
        env:
          - name: JOB_NAME
            value: "ListedStockSymbolPubJob"
          - name: TARGET_MODULE
            value: "job"

```

환경변수 넘겨서 실행 ㄱㄱ

문제점 : docker repo size 1.3기가(…)

그냥 ci 파이프라인을 개선하는 것이 맞다고 본다..

