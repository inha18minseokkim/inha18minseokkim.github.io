---
title: "mediation 패턴 도입기 - 케이뱅크 내부에서 webflux의 한계(20241130기준)"
date: 2024-11-30
tags:
  - 개발
  - 아키텍처
  - Java
category:
  - 실무경험
---
openfeign-reactive wrapper를 도입한 이유는 다음과 같다
1. 동시성 제어
2. 스레드 블로킹 되는 구간에서 좀 더 효율적인 처리
  1. 내가 그냥 이 시점에 이 api들 호출해서 이렇게 조합해서 내보내야됨. 처리 순서는 Mono,Flux,스트림 형식으로 정해줄테니 그냥 스케줄러 너가 알아서 호출순서 정해서 던져줘 라는 감성으로 코드를 짬. 이건 개인적으로 마음에 듬.
3. feign 활용 코드의 가독성

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/c38aebd7-2834-4fac-b2fc-a2f0c17ce81d/5cbb1bde-27ef-40c0-8da0-40100086fdf7/image.png)

한계점
1. 아직까지 주식 업무에서 논블로킹이 필수적으로 들어갈만한 업무가 없음. 
2. 있다고 하더라도 백엔드 구간은 어느정도 논블로킹으로 100% 구현 가능한데, MCI에 리턴할 때 블로킹으로 줘야함. lazy 로딩 이런거 없음. 레이지하게 프론트에서 호출 와바박 하는 순간 10개중 두세개 유실됨
3. 나 포함 아직 논블로킹 호출에 대해서 행내에서 개발하는 사람이 없음. 그리고 아직 백엔드에 r2dbc를 붙이는 등 reactive하게 구성하고 있지 않음. 
4. 그러므로 현재 openfeign에 reactive를 래핑하여 얻은 이점은 스레드 블로킹되는 구간에서 효율적인 처리를 할 수 있다는것 정도. 상당히 제한적이라 좀 아쉽다.
  1. 다만 이것도 reactive를 사용하지 않고 openfeign + completableFuture를 사용하면 현재 행에서 오는 호출들 유형은 다 처리할 수 있어서 왜 굳이 reactor를 쓰셨어요? 라고 물어보면 딱히 적극적으로 변호할만한 건덕지가 없다 ..
5. 현재까지는 단일 호출에서 긴 시간이 걸리는 거래가 없어서 가능한듯.
  1. [nGrinder에 적용한 HttpCore 5와 HttpClient 5 살펴보기](https://d2.naver.com/helloworld/0881672)
  2. Long job의 경우 다음 소켓 채널이 대기하는 시간이 길어질 수 있어 무조건 reactive를 사용하는것도 지양해야할듯함. 물론 한트랜잭션이 이만큼 길어진다는건 서비스 구성부터 다시 검토하긴 해야겠지만.

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/c38aebd7-2834-4fac-b2fc-a2f0c17ce81d/48726314-a9a3-45f4-b286-cd5c58bd287d/image.png)
