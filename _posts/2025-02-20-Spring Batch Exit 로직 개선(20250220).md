---
title: "Spring Batch Exit 로직 개선(20250220)"
date: 2025-02-20
tags: [미지정]
category:
  - 기술
---

## 2023년 POC 당시 표준(은 아니고 이렇게 하기로 합의함)


```java
public class ListedStockSubJobApplication {

	public static void main(String[] args) {
		System.exit(SpringApplication.exit(SpringApplication.run(ListedStockSubJobApplication.class, args)));
	}

}
```

현재 케이뱅크에서 Spring Batch는 데몬서버에서 스레드 독립적인 Task를 기동하는 형식이 아니라 Pod 실행 시 CommandLine에 의해 작동되고 다운되는 어플리케이션 형식이다.
기동되고 Spring Boot Starter Batch의 Default Batch Configuration에 의해 Batch관련 빈들과 JobLauncher들이 자동으로 실행되는 방식으로 사용하였다. 
  - 즉 java -jar 기동 시 작업이 돌고 끝.
이렇게 했을 때 문제점이 Spring Batch Job이 기동하다가 에러가 났을 때 Throw Exception을 하지만 자바 자체는 종료 시 0을 리턴하여 별도로 저렇게 System.exit으로 리턴 코드를 넘겨줬다.


## 개선점


```java
@Override
public void run(ApplicationArguments args) throws Exception {
    TaskExecutorJobLauncher jobLauncher = new TaskExecutorJobLauncher();

    jobLauncher.setJobRepository(jobRepository);
    jobLauncher.setTaskExecutor(task -> {
        log.info("ListedStockAggregate 적재 시작 @@@@@@");
        task.run();
    });
    ExitStatus exitStatus = jobLauncher.run(aggregateBatchJob(),jobParameters()).getExitStatus();
		if(!ExitStatus.COMPLETED.equals(exitStatus)) {
			throw new IllegalArgumentException();
		}    
}
```

@ConditionalOnProperty를 사용해서 어떤 Job Configuration Bean을 jar 기동 시점에 띄울거냐를 결정하고, 해당 Configuration Class 에서 ApplicationRunner를 작동시킬 때, 위 메서드에서 나온것 처럼 TaskExecutorJobLauncher를 기동한다.
Batch Job에서 오류가 발생한 경우 ExitStatus가 COMPLETED가 아니므로 에러를 Throw 하거나 SpringApplicaiton Exit 1을 수행하면 된다.


### 2년전 System exit를 사용했던 이유

spring batch 기본 설정을 사용하는 경우(job 관련 빈을 따로 정의 하지 않고)
ApplicationRunner를 상속하는 JobLauncherApplicationRunner를 자동으로 만들어서 수행한다
> [`ApplicationRunner`](https://docs.spring.io/spring-boot/api/java/org/springframework/boot/ApplicationRunner.html) to `launch` Spring Batch jobs. If a single job is found in the context, it will be executed by default. If multiple jobs are found, launch a specific job by providing a jobName.
> 
> Disable this behavior with spring.batch.job.enabled=false.
[JobLauncherApplicationRunner (Spring Boot 3.4.2 API)](https://docs.spring.io/spring-boot/api/java/org/springframework/boot/autoconfigure/batch/JobLauncherApplicationRunner.html)

이 소스코드를 쭉 따라가보면



```java
	private void executeLocalJobs(JobParameters jobParameters) throws JobExecutionException {
		for (Job job : this.jobs) {
			if (StringUtils.hasText(this.jobName)) {
				if (!this.jobName.equals(job.getName())) {
					logger.debug(LogMessage.format("Skipped job: %s", job.getName()));
					continue;
				}
			}
			execute(job, jobParameters);
		}
	}
```

job을 실행시키고 별도의 동작을 따로 하진 않는다.
그러다보니 아무 설정 없이 기본 JobLauncherApplicationRunner 를 사용하면 후속으로 리턴코드 처리를 안해주니 우리가 명시적으로 System.exit(스프링어플리케이션 종료코드) 를 수행했었음.

이번 POC하면서 ApplicationRunner를 별도로 만들어서 jar 기동시 기동시켰기 때문에 이제는 가능함.


# 공통화(안)


```java
public class ListedStockSubJobApplication implements ApplicationRunner {

	public static void main(String[] args) {
		SpringApplication.run(ListedStockSubJobApplication.class, args);
	}

	
	private final JobRepository jobRepository;
	private final JobParameters jobParameters;
	@Override
	public void run(ApplicationArguments args) throws Exception {
		TaskExecutorJobLauncher jobLauncher = new TaskExecutorJobLauncher();

		jobLauncher.setJobRepository(jobRepository);
		jobLauncher.setTaskExecutor(task -> {
			log.info("Spring Batch Application 기동 시작 @@@@@@");
			task.run();
		});
		ExitStatus exitStatus = jobLauncher.run(aggregateBatchJob(), jobParameters()).getExitStatus();
		if(!ExitStatus.COMPLETED.equals(exitStatus)){
			throw new KbankBatchException("대충 배치 실패 했다는 내용");
		}
	}
}

```

이 프로젝트의 목적이 단순히 배치 어플리케이션만을 기동시키겠다는 목적이면, main class에 공통 jobLauncher를 구성할 수 있다. 이렇게 하고 세부 Job Configuration 명세를 한 다음 ConditionalOnProperty를 사용하여 어떤 Job Bean을 주입할지 정하면 될 듯 하다.

물론 배치뿐만 아니라 단순 자바 코드 기동의 형태의 작업도 섞여있으면 main 클래스에 공통으로 launcher를 넣는것은 불가능하다.


[[Spring] Spring Batch Job 동작 과정](https://velog.io/@seongwop/Spring-Spring-Batch-Job-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95)
