---
title: "JPA 사용"
date: 2024-01-10
tags: [미지정]
category:
  - 기술
---

### UML


![](/assets/images/Pasted%20image%2020260228171241_17dd8e8c.png)

기존 Mybatis에서 테이블 건들지 않으면서 최대한 객체지향적으로 다시 짜봄 + pk 정리

### 디렉터리 구조


```sql
controller
domain
infrastructure
	dto
		각각의 dto들
	impl --> ~~~RepositoryCustom에 대한 구현체
		BaseProductRepositoryImpl
		CustomerSearchHistoryRepositoryImpl
		InnerProductRepositoryImpl
		MemberInfoRepositoryImpl
		ProcessedPriceInfoRepositoryImpl
	interfaces --> JPARepository로 안되는 동적쿼리 + 특수 로직들 넣음
		BaseProductRepositoryCustom
		CustomerSearchHistoryRepositoryCustom
		InnerProductRepositoryCustom
		MemberInfoRepositoryCustom
		ProcessedPriceInfoRepositoryCustom
	mapper
		BaseProductRepositoryMapper
		InnerProductRepositoryMapper
		ProcessedPriceInfoRepositoryMapper
	repository --> 기본 JPARepository를 상속받음. 엔티티(테이블)별로 
		BaseProductRepository
		CustomerInterestProductRepository
		CustomerSearchHistoryRepository
		InnerCategoryRepository
		InnerProductRepository
		MemberInfoRepository
		ProcessedPriceInfoRepository
		UserCodeRepository
		UserGroupCodeRepository
```

1. Entity 기본 JPARepository는 repository 디렉터리에
2. custom 로직은 ~~RepositoryCustom에
3. custom로직 구현은  impl에
4. RepositoryCustom  인터페이스는 직접 호출하지 않는다.
 

```java
@Repository
public interface BaseProductRepository extends JpaRepository<BaseProduct,Long> , BaseProductRepositoryCustom {
    Optional<BaseProduct> findByCategoryCodeAndItemCodeAndKindCodeAndClassCodeAndGradeCode
            (String categoryCode,String itemCode,String kindCode,String classCode,String gradeCode);
}
```

BaseProductCustom 인터페이스와 JPARepository를 모두 상속하도록 함

```java
public interface BaseProductRepositoryCustom {
    List<FindBaseProductWithFilterOut> findBaseProductWithFilter(FindBaseProductWithFilterIn in);
}
```

이렇게 interface 선언

```java
@Repository
@RequiredArgsConstructor
public class BaseProductRepositoryImpl implements BaseProductRepositoryCustom {
    private final EntityManager em;
    private final BaseProductRepositoryMapper mapper;
    @Override
    public List<FindBaseProductWithFilterOut> findBaseProductWithFilter(FindBaseProductWithFilterIn in) {
        JPAQueryFactory query = new JPAQueryFactory(em);
        QBaseProduct baseProduct = QBaseProduct.baseProduct;
.......
```

해당 interface를 impl 하는 로직을 빈등록 해놓음
그렇게 하고

```java
@Override
    public List<GetBaseCodesResult> getBaseCodes(GetBaseCodesCriteria in){
        List<FindBaseProductWithFilterOut> results = baseProductRepository
                .findBaseProductWithFilter(mapper.from(in));
        return results.stream()
                .map((element) -> mapper.from(element)).collect(Collectors.toList());
    }
```

하나의 Repository에서 커스텀 로직 호출 가능
다만 테이블 하나에 쿼리 하나면 “이 Data Access 로직은 여기가 맞다” 가 되지만 여러 테이블 조인하는 경우는 애매하므로 도메인에 맞게 폴더를 지정할 필요는 있음. 일단 이런식으로 쓸 수 있다고 보여주려고 하다보니 Domain별로 분리를 못했다.

만약에 쿼리를 써야할 일이 있다면 customRepository interface에 메서드 선언 후 구현부에서 mybatis,JPA,JDBC 중 하나를 선택해서 구현하면 됨
QueryDSL 예시

```java
@Override
    public List<GetPriceDiffListOut> getPriceDiffList(GetPriceDiffListIn in){
        QProcessedPriceInfo processedPriceInfo = QProcessedPriceInfo.processedPriceInfo;
        QUserGroupCode userGroupCode = QUserGroupCode.userGroupCode;
        QUserCode userCode = QUserCode.userCode;
        QInnerProduct innerProduct = QInnerProduct.innerProduct;
        QBaseProduct baseProduct = QBaseProduct.baseProduct;
        JPAQueryFactory query = new JPAQueryFactory(entityManager);


        List<Tuple> result = query.select(
                        innerProduct
                        ,processedPriceInfo.baseDate
                        ,processedPriceInfo.price.avg()
                )
                .from(innerProduct)
                .join(baseProduct)
                    .on(baseProduct.innerProduct.id.eq(innerProduct.id))
                .leftJoin(processedPriceInfo)
                    .on(processedPriceInfo.baseProduct.id.eq(baseProduct.id))
                .join(userCode)
                    .on(processedPriceInfo.regionInfo.eq(userCode))
                .where(
                        innerProduct.isAvailable.eq(true)
                                ,(processedPriceInfo.baseDate.between(in.getStartDate(), in.getEndDate())
                                        .or(processedPriceInfo.baseDate.isNull())
                                )
                                ,(processedPriceInfo.baseRange.eq(BaseRange.DAY)
                                        .or(processedPriceInfo.baseRange.isNull())
                                )
                                ,(processedPriceInfo.regionInfo.eq(userCode)
                                        .or(processedPriceInfo.regionInfo.isNull())
                                )
                                ,(userCode.userGroupCode.eq(in.getRegionGroup()))
                ).groupBy(
                        innerProduct,
                        processedPriceInfo.baseDate
                )
                .fetch();
        return result.stream().map(element -> 
							GetPriceDiffListOut.builder()
								.innerProduct(element.get(innerProduct))
                .price(Optional.ofNullable(element.get(processedPriceInfo.price.avg())))
                .baseDate(Optional.ofNullable(element.get(processedPriceInfo.baseDate)))
                .build())
							.collect(Collectors.toList());
    }
```

다만 QueryDSL을 사용하는 로직의 경우 자기 형제 Repository를 호출하는 이상한 구조가 될 수 있어서 Reader로 빼는게 맞긴할듯함.


[Query based→ OOP 전환 커브]({% post_url 2024-02-02-Query based→ OOP 전환 커브 %})
