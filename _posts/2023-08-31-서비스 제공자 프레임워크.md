---
title: "서비스 제공자 프레임워크"
date: 2023-08-31
tags: [미지정]
---
확장가능한 어플리케이션을 만들 수 있겠냐? 
코드는 그대로 유지하되 외적인 요인을 변경했을 때 의도한대로 다르게 잘 돌아가는지
설정파일을 바꿔도 잘돌아가(param을 dynamic하게)
콘솔로 작동하던걸 이메일로 돌아가는지(출력계층 추상화)
외적인 요인으로 확장 가능

```java
public interface HelloService {
	String hello();
}
```


```java
public static void main(String[] args){
	ServiceLoader<HelloService> loader = ServiceLoader.load(HelloService.class);
	Optional<HelloService> helloServiceOptional = loader.findFirst();
	helloServiceOptional.ifPresent(h ->
		System.out.println(h.hello());
	});
}
```

서비스 제공 api - 서비스 구현체 등록하는 기능 제공 ex) Spring Configuration, Bean메서드로 서비스 등록
서비스 접근 api - 서비스를 가져오는 방법 

```java
public class App {
	public static void main(String[] args) {
		ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.clas);
		HelloService helloService = applicationContext.getBean(HelloService.class);
		System.out.println(helloService.hello());
}
```

또는 Autowired 방법이 있음
Spring을 사용할 때의 서비스 제공자 프레임워크임

# Bridge Pattern

구체적인것과 추상적인것을 분리

```java
public abstract class App implements Champion{
	public static void main(String[] args) {
		Champion Kda아리 = new 아리(new KDA());
		kda아리.skillQ();
		kda아리.skillW();

		Champion poolParty아리 = new 아리(new PoolParty());
		poolParty아리.skillR();
		poolParty아리.skillW();
	}
}
```

서로 영향을 주지 않으면서 각기 다른 버전으로 발전가능
Champion과 skin을 구분하지 않으면 skin만들 때 마다 champion에 대응되는 각 skin을 모두 만들어줘야함
